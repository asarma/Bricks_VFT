define(function(require, exports, module) {
"use strict";

var util = require("./util");
var EventEmitter = require("events").EventEmitter;

/**
 * Makes sure that each messages reaches the receiver. Uses sliding windows
 * and acknowledgements to guarantee that.
 * 
 * @param socket {ReconnectSocket} The transport layer for the reliable socket
 * @param options {Object} Options to specify
 *   object:
 *   windowSize     {Number} number of packets to buffer before signalling the 
 *                           sender to throttle sending.
 *   seq            {Number} initial sequence number
 *   ackTimeout     {Number} time to wait in ms before auto ack received messages
 *   disconnectTimeout {Number} time to waint in away state before disconnecting
 *                           the connection
 */
var ReliableSocket = module.exports = function(socket, options) {
    EventEmitter.call(this);
    
    this.socket = socket;

    options = options || {};
    this.options = options;
    
    this.windowSize = options.windowSize || 100;
    this.ackTimeout = options.ackTimeout || 200;
    this.disconnectTimeout = options.disconnectTimeout || 10 * 1000;
    this.retransmissionTimeout = 3000;
    
    this.debug = options.debug || false;
    this.seq = options.seq || 1;
    this.recId = -1;
    this.connected = false;
    
    // messages sent while not connected
    this.buffer = [];
    
    // sent but not yet acknowledged messages
    this.unacked = {};
    
    socket.on("message", this.onMessage.bind(this));
    socket.on("away", this.onAway.bind(this));
    socket.on("back", this.onBack.bind(this));
};

util.inherits(ReliableSocket, EventEmitter);

Object.defineProperty(ReliableSocket.prototype, "readyState", {
    get : function() { 
        return this.socket.readyState;
    }
});

ReliableSocket.prototype.onMessage = function(msg) {
    if (typeof msg == "string") {
        try {
            msg = JSON.parse(msg);
        } catch(e) {}
    }
    this.debug && console.log("on message", msg, this.seq);
    
    if (!msg || !msg.ack)
        return;
        
    // remove acknowledged messages from our buffer
    var ack = msg.ack;
    for (var key in this.unacked) {
        var unacked = this.unacked[key];
        if (unacked.seq <= ack)
            unacked.acknowledge();
    }

    if (Object.keys(this.unacked).length < this.windowSize)
        this.emit("drain");
        
    var recId = msg.seq;
    if (recId) {
        var expectedId = this.recId + 1;
        if (recId == expectedId || this.recId == -1) {
            this.recId = recId;
            this._delayedAck();
        } else if (recId < expectedId) {
            this.debug && console.log("dupe", recId, expectedId);
            // we already saw this packet. Make sure the other side knows it
            this._delayedAck();
            return;
        } else {
            this.debug &&  console.log("miss", recId, expectedId);
            // we miss packets in between
            this._ack();
            return;
        }
    }
    
    if (msg.d) 
        this.emit("message", msg.d);
};

ReliableSocket.prototype.onAway = function() {
    this.debug && console.log("away");
    this._scheduleDisconnect("client connection went away");
    this.emit("away");
};

ReliableSocket.prototype.onBack = function() {
    this.debug && console.log("back");
    this._cancelDisconnect();
    
    if (!this.connected) {
        this.connected = true;
        this.emit("connect");
    }
    this.emit("back");
    
    if (this.buffer.length)
        this._flush();
    else
        this._ack();
};

ReliableSocket.prototype._scheduleDisconnect = function(reason) {
    var that = this;
    this._cancelDisconnect();
    this.debug && console.log("schedule disconnect");
    this._disconnectTimer = setTimeout(function() {
        that.disconnect(reason);
    }, this.disconnectTimeout);
};

ReliableSocket.prototype._cancelDisconnect = function() {
    this.debug && console.log("cancel disconnect");
    clearTimeout(this._disconnectTimer);
};

ReliableSocket.prototype._delayedAck = function() {
    var that = this;
    this._cancelDelayedAck();
    this._ackTimer = setTimeout(function() {
        that._ack();    
    }, this.ackTimeout);
};

ReliableSocket.prototype._cancelDelayedAck = function() {
    clearTimeout(this._ackTimer);
};

ReliableSocket.prototype._ack = function() {
    if (this.socket.readyState == "open") {
        this.debug && console.log("send ack", this.recId);
        this.socket.send(JSON.stringify({
            ack: this.recId
        }));
    }
};

ReliableSocket.prototype._flush = function() {
    var that = this;
    if (this.socket.readyState == "open") {
        this._cancelDelayedAck();
        
        this.buffer.forEach(function(msg) {
            that.debug && console.log("flush", msg);
            that._sendMessage(msg);
        });
        
        this.buffer = [];
    }
};

ReliableSocket.prototype.disconnect = function(reason) {
    this.debug && console.log("disconnect");
    this.connected = false;
    this.recId = -1;
    
    this.buffer = [];
    for (var key in this.unacked) {
        this.unacked[key].abort();
    }
    this.unacked = {};
    
    this.close();
    this.emit("away");
    
    var err = new Error("EDISCONNECT: " + (reason || "Client disconnected?"));
    err.code = "EDISCONNECT";
    this.emit("disconnect", err);
};

ReliableSocket.prototype.close = function() {
    return this.socket.close();
};

ReliableSocket.prototype.send = function(msg) {
    this._cancelDelayedAck();
    if (this.socket.readyState == "open") {
        return this._sendMessage(msg);
    }
    else {
        this.debug && console.log("buffer", msg);
        this.buffer.push(msg);
        return false;
    }
};

ReliableSocket.prototype._sendMessage = function(data) {
    var that = this;
    
    var msg = {
        seq: ++this.seq,
        ts: Date.now(),
        tries: 0,
        send: function() {
            msg.abort();
            that.unacked[msg.seq] = msg;
            msg.retransmissionTimer = setTimeout(function() {
                msg.tries += 1;
                msg.send();
            }, that.retransmissionTimeout);
            that.debug && console.log("send", msg.serialize(), that.retransmissionTimeout);
            that.socket.send(msg.serialize());
        },
        abort: function() {
            delete that.unacked[msg.seq];
            clearTimeout(msg.retransmissionTimer);
        },
        acknowledge: function() {
            msg.abort();
            if (!msg.tries)
                that._updateRetransmissionTimeout(Date.now() - msg.ts);
        },
        serialize: function() {
            return JSON.stringify({
                ack: that.recId,
                seq: msg.seq,
                d: data
            });
        }  
    };
    
    msg.send();
    return Object.keys(this.unacked).length < this.windowSize;
};

// use TCP algorithm to compute the retransmission timeout
// http://de.wikipedia.org/wiki/Transmission_Control_Protocol#Retransmission_Timer
ReliableSocket.prototype._updateRetransmissionTimeout = function(rtt) {
    if (!this.srtt) {
        this.srtt = rtt;
        this.rttVar = 0.5 * rtt;
        this.retransmissionTimeout = rtt * this.rttVar;
    }
    else {
        var alpha = 1/8;
        var beta = 1/4;
        this.srtt = (1-alpha) * this.srtt - alpha * rtt;
        this.rttVar = (1-beta) * this.rttVar + beta * (Math.abs(this.srtt - rtt));
        this.retransmissionTimeout = this.srtt + 4 * this.rttVar;
    }
    
    this.retransmissionTimeout = Math.min(Math.max(this.retransmissionTimeout, 500), 8000);
};

});