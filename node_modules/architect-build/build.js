var fs         = require("fs");
var path       = require("path");
var async      = require("async");
var mkdirp     = require("mkdirp");
var moduleDeps = require("./module-deps");
var less       = require("less");

function build(config, opts, callback){
    // Get Architect Config
    if (typeof config == "string") {
        fs.readFile(config, "utf8", function(err, data){
            if (err) return callback(err);
            var str = data.match(/require.plugins\s*=\s*(\[[\s\S]*\])/)[1];
            
            try { var json = eval(str); }
            catch(e) { return callback(e); }
            
            opts.configFile = data;
            build(json, opts, callback);
        });
        return;
    } else if (!opts.configFile) {
        opts.configFile = "\nrequire.plugins = "
            + JSON.stringify(config, null, 4)
            + ";\n";
    }
    
    // Load all architect modules as main files
    var mains = [], options = {};
    config.forEach(function(pkg){
        if (typeof pkg == "string") {
            mains.push(pkg);
        }
        else if (pkg.packagePath) {
            mains.push({
                id: pkg.packagePath,
                parent: {id: "#root"},
                plugin: pkg
            });
            options[pkg.packagePath] = pkg;
        }
    });
    
    // Add additional packages
    (opts.additional || []).forEach(function(relPath, i){
        mains.unshift(typeof relPath === "object" ? relPath : {
            id      : null,
            path    :  path.resolve(__dirname + "/" + relPath),
            order   : -i,
            literal : true
        });
    });
    
    if (!mains.length)
        return callback(new Error("Config contains no packages"));
    
    // Add Architect    
    if (!opts.noArchitect) {
        mains.push("lib/architect/architect");
        (opts.ignore || (opts.ignore = [])).push(
            //path.resolve(__dirname + "/../architect/events"),
            path.resolve(__dirname + "/../architect/path"),
            path.resolve(__dirname + "/../architect/fs")
        );
    }
    
    // Add RequireJS
    if (opts.withRequire) {
        mains.unshift({
            id: null,
            path: path.resolve(__dirname + "/build_support/mini_require.js"),
            order: -1000,
            noRequire: true,
            mini_require: true
        });
    }
        
    if (opts.moduleLoadUrl) {
        opts.transforms = opts.transforms || [];
        opts.transforms.push(function(module) {
            if (module.mini_require) {
                module.source = module.source.replace(/^\s*var\s+MODULE_LOAD_URL\s*=\s*["'].*["']/m, 'var MODULE_LOAD_URL = "' + opts.moduleLoadUrl + '"');
            }
        });
    }
    
    // Find their deps
    var stream = moduleDeps(mains, opts);
    stream.on("end", function() {
        // sort modules
        var sources = [];
        var modules = opts.modules;
        var added = Object.create(null);
        function addModule(id) {
            var pkg = modules[id] || {};
            if (added[pkg.id])
                return;
            added[pkg.id] = true;
            if (!pkg.source)
                return;
            if (pkg.deps)
                pkg.deps.forEach(addModule);
            sources.push(pkg);
            pkg.pkgIndex = sources.length;
            added[pkg.id] = true;
        }
        Object.keys(modules).forEach(addModule);
        
        // Filter sources
        (opts.filter || []).forEach(function(filter){
            sources = sources.filter(function(pkg){
                return pkg.id.indexOf(filter) !== 0;
            });
        });
        
        sources.sort(function(a, b) {
            return ((a.order|0) - (b.order|0)) || (a.pkgIndex - b.pkgIndex);
        });

        if (opts.compileLess)
            return compileLess(opts, sources, callback);
        
        if (opts.stripLess)
            stripLess(sources);
            
        // Rewrite all the defines to include the id as first arg
        rewriteDefines(sources);
        
        // Include the architect config at the end in the same way as the tests
        if (!opts.noArchitect)
            includeArchitect(opts, sources);
        
        console.log("Processing " + sources.length + " files.");
        
        // Concatenate all files using uglify2 with source maps
        var result;
        console.log("Compressing: ", opts.compress);
        if (opts.compress)
            result = require("./compress")(sources, opts);
        else {
            result = {
                code : sources.map(function(src){ return src.source; }).join("\n"),
                map : ""
            };
        }

        if (typeof opts.outputFolder == "string") {
            writeToFile(result, opts, callback);
        }
        else {
            callback(null, result);
        }
    });
}

// TODO
function createOutputFolder(opts, cb) {
    var output = (opts.outputFolder || ".") + "/" + (opts.outputFile || "");
    output = path.dirname(output);
    mkdirp(output, cb);
}

function compileLess(opts, sources, callback) {
    var less = stripLess(sources);
    var code = [];
    
    async.forEachSeries(less, function(file, next) {
        var plugin = file.pkg.parent.plugin || {};
        
        if (file.pkg.id.match(/(keyframes|font-awesome)\.css$/)) {
            code.push(file.code
                .replace(/@\{image-path\}/g, plugin.staticPrefix + "/images")
                .replace(/@\{base-path\}/g,  plugin.staticPrefix)
            );
            
            return next();
        }
        var root = path.join(opts.basepath, (plugin.packagePath ? path.dirname(plugin.packagePath) : "/"));
        compileLessFragment(file.code, opts.lessLibs, root, plugin.staticPrefix, file.path, opts.compress, function(err, css) {
            if (err)
                return callback(err);
            
            code.push(css);
            next();
        });
    }, function(err) {
        callback(err, {
            code: code.join("\n")
        });
    });
}

function compileLessFragment(css, libs, root, staticPrefix, path, compress, callback) {
    var baseLib = "@base-path : \"" + staticPrefix + "\";\n"
        + "@image-path : \"" + staticPrefix + "/images\";\n"
        + "@icon-path : \"" + staticPrefix + "/icons\";\n";
    
    var parser = new less.Parser({
        paths: ["/"],
        filename: root + '/unknown.less',
    });
    
    // Parse Less Code
    var code = baseLib + "\n" + libs.join("\n") + "\n" + css;
    
    console.log("compiling", path || "skin", root);
    parser.parse(code, function (err, tree) {
        if (err)
            return callback(err);
        
        callback(null, tree.toCSS({ 
            compress: compress
        }));
    });
}

function stripLess(sources) {
    var less = [];

    function addLessFile(pkg, code, file) {
        less.push({
            pkg: pkg,
            code: code,
            path: file
        });
    }
    
    sources.forEach(function(pkg){
        if (pkg.id && (pkg.id.indexOf("text!") > -1) && pkg.id.match(/text\!.*\.(less|css)$/)) {
            var source = pkg.source;
            pkg.source = "";
            
            // ignore certain less files
            if (pkg.id.match(/(default-dark|default-white|lesshat|compile_dark|compile_.*?)\.(less|css)/))
                return;
                
            // console.log("dropping less", pkg.id);
            addLessFile(pkg, source, pkg.file);
        }
        else if (pkg.id && pkg.id.match(/^text\!.*\.xml$/) && pkg.source.match(/<a:skin.*?\s+xmlns:a="http:\/\/ajax.org\/2005\/aml"/m)) {
            pkg.source = pkg.source.replace(/(<a:style><\!\[CDATA\[)([\s\S]*?)(\]\]>)/g, function(m, open, css, close) {
                addLessFile(pkg, css);
                // console.log("dropping css in skin", pkg.id);
                return open + close;
            });
        }
    });
    
    return less;
}

function rewriteDefines(sources){
    sources.forEach(function(pkg){
        if (!pkg.source && !pkg.id)
            console.log(pkg);
        if (!pkg.id) {
            // include literal
        }
        else if (pkg.id.indexOf("text!") > -1) {
            var source = pkg.source.replace(/\n/g, "\\n").replace(/"/g, '\\"');
            pkg.source = 'define("' + pkg.id + '",[],"'
                + source
                + '");';
        }
        else {
            pkg.source = pkg.source.replace(/define\((\s*[\[f])/, "define(\"" + pkg.id + '",[], $1');
        }
    });
}

function includeArchitect(opts, sources) {
    var source;
    if (opts.includeConfig) {
        source = opts.configFile + ";";
    }
    else {
        source = 'require(["architect", "./architect-config"], function (architect, plugins) {\n'
            + '    architect.resolveConfig(plugins, function (err, config) {\n'
            + '        if (err) throw err;\n'
            + '        architect.createApp(config);\n'
            + '    });\n'
            + '});\n';
        
        var output = (opts.outputFolder || ".") + "/" + (opts.outputFile || "architect-config.js");
        fs.writeFile(output, opts.configFile, function(err){
            if (!err)
                console.log("Written config file in '" + output + "'.");
        });
    }
    
    sources.push({
        id     : "bootstrap",
        file   : "bootstrap",
        source : source
    });

}


function writeToFile(result, opts, callback) {
    // Write output code
    createOutputFolder(opts, function() {
        var output = (opts.outputFolder || ".") + "/" + (opts.outputFile || "build.js");
        fs.writeFile(output, result.code, function(err){
            if (err) return callback(err);
            console.log("Written output in '" + output + "'");
        });
        
        // Write map file
        if (opts.mapFile && result.map) {
            output = (opts.outputFolder || ".") + "/" + opts.mapFile;
            fs.writeFile(output, result.map, function(err){
                if (err) return callback(err);
                console.log("Written map file in '" + output + "'");
            });
        }
    });
}

module.exports = build;
