/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define(function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;
var dom = require("ace/lib/dom");
var event = require("ace/lib/event");

var EditSession = require("ace/edit_session").EditSession;
var UndoManager = require("ace/undomanager").UndoManager;
var Renderer = require("ace/virtual_renderer").VirtualRenderer;
var Editor = require("ace/editor").Editor;
var MultiSelect = require("ace/multi_select").MultiSelect;

var EditableTree = function(tree) {
    this.tree = tree;    
    this.tree.on("click", this.onClick = this.onClick.bind(this));
    this.tree.on("blur", this.onTreeBlur = this.onTreeBlur.bind(this));
    this.tree.on("focus", this.onTreeFocus = this.waitForRename.bind(this));
    this.tree.on("mousedown", this.onMouseDown = this.onMouseDown.bind(this));    
    this.tree.on("dblclick", this.onDoubleClick = this.onDoubleClick.bind(this));    
    this.tree.on("startDrag", this.onTreeBlur);
    this.timer = null;
};

(function() {
    this.RENAME_DELAY = 400;
    this.onTreeBlur = function(e) { this.cancel() };
    
    this.onDoubleClick = function(e) {
        var node = e.getNode();
        if (this.tree.provider.columns) {
            if (e.domEvent.detail == 2 && node) {
                var columnData = this.tree.renderer.$headingLayer.findColumn(e.getDocumentPosition().x);
                var column = columnData && columnData.column;
                if (column.editor) {
                    this.startRename(node, column);
                    e.stop();
                }
            }
            return;
        }
    };
    this.onMouseDown = function(e) {
        this.cancel();
        if (e.domEvent.detail > 1 || e.getButton() !== 0) {
            return;
        }
        var sel = this.tree.selection.getSelectedNodes();
        if (sel.length == 1 &&  e.editor.isFocused() && !this.afterRename) {
            this.lastNode = sel[0];
        }
    };
    this.cancel = function() {
        if (this.timer)
            clearTimeout(this.timer);
        this.lastNode = null;
    };
    this.waitForRename = function() {
        this.afterRename = setTimeout(function() {
            this.afterRename = null;
        }.bind(this), 10);
    };
    this.onClick = function(e) {
        var node = e.getNode();
        if (this.tree.provider.columns)
            return;
        var lastNode = this.lastNode;
        this.cancel();
        var sel = this.tree.selection.getSelectedNodes();
        if (sel.length != 1)
            return;
        
        if (!node || !lastNode || node != sel[0] || node != lastNode)
            return;
        this.timer = setTimeout(function() {
            this.cancel();
            var sel = this.tree.selection.getSelectedNodes();
            if (lastNode === sel[0] && sel.length == 1) {
                this.startRename(lastNode);
            }
        }.bind(this), this.RENAME_DELAY);
    };
    this.createEditor = function(el) {
        var renderer = new Renderer(el);

        renderer.screenToTextCoordinates = function(x, y) {
            var pos = this.pixelToScreenCoordinates(x, y);
            return this.session.screenToDocumentPosition(
                Math.min(this.session.getScreenLength() - 1, Math.max(pos.row, 0)),
                Math.max(pos.column, 0)
            );
        };
        renderer.setStyle("ace_one-line");
        renderer.setStyle("ace_tree-editor");
        var editor = new Editor(renderer);
        editor.session.setUndoManager(new UndoManager());

        editor.setShowPrintMargin(false);
        editor.renderer.setShowGutter(false);
        editor.renderer.setHighlightGutterLine(false);
        editor.$mouseHandler.$focusWaitTimout = 0;
        editor.renderer.setPadding(1);
        // editor.container.style.font = "inherit";
        
        return editor;
    };
    
    this._initEditor = function() {
        this.ace = this.createEditor();
        this.ace.treeEditor = this;
        this.ace.commands.bindKeys({
            "Esc": function(ace) {
                ace.treeEditor.endRename(true);
                ace.treeEditor.tree.focus();
            },
            "Enter": function(ace) {
                ace.treeEditor.endRename();
                ace.treeEditor.tree.focus();
            },
            "Tab": function(ace) {
                ace.treeEditor.editNext(1);
            },
            "Shift-Tab": function(ace) {
                ace.treeEditor.editNext(-1);
            }
        });
        this.tree.container.appendChild(this.ace.container);
        
        // make sure no one can steal focus from us
        setTimeout(function() {
            if (this.ace) {
                this.ace.focus();
                this.ace.on("blur", this._onBlur = this._onBlur.bind(this));
            }
        }.bind(this), 20);
        this.tree.renderer.on("afterRender", this._onAfterRender = this._onAfterRender.bind(this));
        this.ace.on("execCommand", function() {
            this.tree.reveal(this.renaming, false);
        }.bind(this));
        this.ace.focus();
        this._onAfterRender();
        
        this.tree._emit("createEditor", {ace: this.ace});
    };
    
    this._onBlur = function() {
        if (!this.ace || !this.ace.textInput || !this.renaming)
            return;
        if (this.ace.$mouseHandler.isMousePressed)
            return;
        // for debugging
        // if (document.activeElement === this.ace.textInput.getElement())
        //     return;
        this.endRename();
    };
    
    this.findNextEditPoint = function(dir, node, col) {
        if (col == null)
            col = this.column ? this.column.index : 0;
        if (node == null)
            node = this.renaming;
        var provider = this.tree.provider;
        var columns = provider.columns;
        
        if (columns) {
            var i = col + dir;
            if (columns[i])
                return {node: node, column: i};
        }
        
        var nodeIndex = provider.getIndexForNode(node);
        var newNode = provider.getNodeAtIndex(nodeIndex + dir);
        
        col =  columns && (dir < 0 ? columns.length - 1 : 0);
        return newNode && {node: newNode, column: col};
    };
    
    this.editNext = function(dir) {
        var p = this.findNextEditPoint(dir);
        if (p)
            this.startRename(p.node, p.column);
        else
            this.stopRename();
    };
    
    this._onAfterRender = function() {
        var i = this.tree.provider.getIndexForNode(this.renaming);
        var domNode = this.tree.renderer.$cellLayer.getDomNodeAtIndex(i);
        var style = this.ace.container.style;
        if (!domNode || !domNode.lastChild)
            return style.top = "-100px";
        
        var renameNode = this.column
            ? domNode.children[this.column.index]
            : domNode.lastChild;
        // empty nodes will have wrong height
        if (!renameNode.textContent)
            renameNode.textContent = "\xa0";
            
        var rect = renameNode.getBoundingClientRect();
        var treeRect = this.tree.container.getBoundingClientRect();
        
        if (this.column) {
            var child = renameNode.lastChild;
            var left = rect.left;
            var offset = this.column.type === "tree"
                ? (child.nodeType == 1 ? child.getBoundingClientRect() : rect).left - left - 2
                : 0;
            style.top = rect.top - treeRect.top + "px";
            style.left = rect.left - treeRect.left + offset + "px";
            style.width = rect.width - offset + "px";
            style.height = rect.height + "px";
        } else {
            var maxWidth = Math.max(treeRect.right - 1 - this.tree.renderer.scrollBarV.getWidth() - rect.left, 10);
            style.top = rect.top - treeRect.top + 2 + "px";
            style.left = rect.left - treeRect.left - 2 + "px";
            style.width = maxWidth + "px";
            style.height = rect.height - 4 + "px";
        }
    };
    
    this.startRename = function(node, column) {
        var model = this.tree.provider;
        node = node || this.tree.selection.getCursor();
        if (!node)
            return false;
        if (typeof column == "number" && model.columns)
            column = model.columns[column];
        if (model.columns && node.fullWidth)
            column = model.columns[0];
        if (this.renaming === node && this.column == column)
            return false;

        if (this.renaming)
            this.endRename(true);
        
        if (model.isEditable && !model.isEditable(node) || node.isEditable === false)
            return false;
        
        this.column = column;
        var e = {
            node: node,
            column: column,
            allowRename: true
        };
        this.tree._emit("beforeRename", e);
        
        if (!e.allowRename)
            return;
        this.renaming = e.node;
        this._initEditor();
        
        this.tree._emit("renameStart");
        this.tree.renderer.scrollCaretIntoView(this.renaming);
        this.tree.renderer.visualizeFocus();
        var val = "", endCol = -1;
        if (!this.renaming.isNew) {
            if (column) {
                val = column.getText(this.renaming);
            } else {
                val = model.getText(this.renaming);
                // todo move this to c9.ide.tree?
                endCol = val.lastIndexOf(".");
            }
        }
        if (endCol < 0)
            endCol = val.length;
        this.ace.setValue(val);
        this.ace.selection.setRange(endCol 
            ? new Range(0, 0, 0, endCol)
            : new Range(0, 1, 0, val.length)
        );
    };
    
    this.stopRename =
    this.endRename = function(cancel) {
        var node = this.renaming;
        this.renaming = null;
        this.cancel();
        this.waitForRename();
        if (!this.tree.isFocused())
            this.tree.renderer.visualizeBlur();

        if (!node)
            return;

        this.ace.off("blur", this._onBlur);

        this.tree.renderer.off("afterRender", this._onAfterRender);
        this.ace.blur();
        var val = this.ace.getValue();
        this.ace.destroy();
        if (this.ace.container.parentNode)
            this.ace.container.parentNode.removeChild(this.ace.container);
        this.ace = null;
        
        if (!cancel) {
            this.tree._emit("rename", {
                node: node,
                value: val,
                column: this.column
            });
        }
    };

}).call(EditableTree.prototype);

module.exports = EditableTree;
});
