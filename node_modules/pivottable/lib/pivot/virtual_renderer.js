define(function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var dom = require("./lib/dom");
var event = require("./lib/event");
// var useragent = require("./lib/useragent");
var config = require("./config");

var HorHeadingLayer = require("./layer/horheading").HorHeading;
var VerHeadingLayer = require("./layer/verheading").VerHeading;
var CellLayer = require("./layer/cells").Cells;
var SelectionLayer = require("./layer/selection").Selection;

var ScrollBarH = require("./scrollbar").ScrollBarH;
var ScrollBarV = require("./scrollbar").ScrollBarV;
var RenderLoop = require("./renderloop").RenderLoop;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var pivotCss = require("./requirejs/text!./css/pivot.css");

dom.importCssString(pivotCss, "pivot");

/**
 * The class that is responsible for drawing everything you see on the screen!
 * @class VirtualRenderer
 **/

/**
 * Constructs a new `VirtualRenderer` within the `container` specified, applying the given `theme`.
 * @param {DOMElement} container The root element of the editor
 * @param {Number} cellWidth The default width of a cell in pixels 
 * @param {Number} cellHeight The default height of a cell in pixels 
 *
 * @constructor
 **/

var VirtualRenderer = function(container, cellWidth, cellHeight) {
    var _self = this;

    this.container = container || dom.createElement("div");

    dom.addCssClass(this.container, "pivot");

    this.$horheading = dom.createElement("div");
    this.$horheading.className = "pivot_horheading";
    this.container.appendChild(this.$horheading);

    this.$verheading = dom.createElement("div");
    this.$verheading.className = "pivot_verheading";
    this.container.appendChild(this.$verheading);

    this.scroller = dom.createElement("div");
    this.scroller.className = "pivot_scroller";
    this.container.appendChild(this.scroller);
    
    this.cells = dom.createElement("div");
    this.cells.className = "pivot_cells";
    this.scroller.appendChild(this.cells);
    
    this.cover = dom.createElement("div");
    this.cover.className = "pivot_cover";
    this.container.appendChild(this.cover);

    this.$verHeadingLayer = new VerHeadingLayer(this.$verheading, cellWidth, cellHeight);
    this.$horHeadingLayer = new HorHeadingLayer(this.$horheading, cellWidth, cellHeight);
    this.$selectionLayer  = new SelectionLayer(this.cells, this);
    
    var rsz = this.onResize.bind(this);
    this.$verHeadingLayer.on("changeWidth", function(){
        rsz(true);
    });
    this.$horHeadingLayer.on("changeHeight", function(){
        rsz(true);
    });

    this.$cellLayer = new CellLayer(this.cells);
    this.canvas = this.$cellLayer.element;

    // Indicates whether the horizontal scrollbarscrollbar is visible
    this.$horizScroll = false;

    this.scrollBarV = new ScrollBarV(this.container);
    this.scrollBarV.setVisible(true);
    this.scrollBarV.addEventListener("scroll", function(e) {
        if (!_self.$inScrollAnimation)
            _self.setScrollTop(e.data);
    });

    this.scrollBarH = new ScrollBarH(this.container);
    this.scrollBarH.addEventListener("scroll", function(e) {
        if (!_self.$inScrollAnimation)
            _self.setScrollLeft(e.data);
    });
    
    this.scrollTop = 0;
    this.scrollLeft = 0;

    this.caretPos = {
        row : 0,
        column : 0
    };

    this.$size = {
        width: 0,
        height: 0,
        scrollerHeight: 0,
        scrollerWidth: 0
    };

    this.layerConfig = {
        width : 1,
        padding : 0,
        firstRow : 0,
        firstRowScreen: 0,
        lastRow : 0,
        lineHeight : 1,
        characterWidth : 1,
        minHeight : 1,
        maxHeight : 1,
        offset : 0,
        height : 1
    };
    
    this.scrollMargin = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        v: 0,
        h: 0
    };

    this.$loop = new RenderLoop(
        this.$renderChanges.bind(this),
        this.container.ownerDocument.defaultView
    );
    this.$loop.schedule(this.CHANGE_FULL);
};

(function() {
    this.CHANGE_SCROLL    = 1;
    this.CHANGE_COLUMN    = 2;
    this.CHANGE_ROW       = 4;
    this.CHANGE_CELLS     = 8;
    this.CHANGE_SIZE      = 16;
    this.CHANGE_SELECTION = 32;
    this.CHANGE_FULL      = 64;

    this.CHANGE_H_SCROLL = 1024;
    // this.$logChanges = function(changes) {
    //     var a = ""
    //     if (changes & this.CHANGE_CURSOR) a += " cursor";
    //     if (changes & this.CHANGE_MARKER) a += " marker";
    //     if (changes & this.CHANGE_GUTTER) a += " gutter";
    //     if (changes & this.CHANGE_SCROLL) a += " scroll";
    //     if (changes & this.CHANGE_LINES) a += " lines";
    //     if (changes & this.CHANGE_TEXT) a += " text";
    //     if (changes & this.CHANGE_SIZE) a += " size";
    //     if (changes & this.CHANGE_MARKER_BACK) a += " marker_back";
    //     if (changes & this.CHANGE_MARKER_FRONT) a += " marker_front";
    //     if (changes & this.CHANGE_FULL) a += " full";
    //     if (changes & this.CHANGE_H_SCROLL) a += " h_scroll";
    //     console.log(a.trim())
    // };

    oop.implement(this, EventEmitter);

    /**
     *
     * Associates the renderer with an DataProvider.
     **/
    this.setDataProvider = function(provider) {
        this.provider = provider;

        this.scroller.className = "pivot_scroller";

        this.$horHeadingLayer.setDataProvider(provider);
        this.$verHeadingLayer.setDataProvider(provider);
        this.$cellLayer.setDataProvider(provider);
        this.$selectionLayer.setDataProvider(provider);
        this.$loop.schedule(this.CHANGE_FULL);
    };

    /**
     * Triggers a partial update of the text, from the range given by the two parameters.
     * @param {Number} firstRow The first row to update
     * @param {Number} lastRow The last row to update
     *
     *
     **/
    this.updateRows = function(firstRow, lastRow) {
        if (lastRow === undefined)
            lastRow = Infinity;

        if (!this.$changedLines) {
            this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
        }
        else {
            if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;

            if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
        }

        if (this.$changedLines.firstRow > this.layerConfig.lastRow ||
            this.$changedLines.lastRow < this.layerConfig.firstRow)
            return;
        this.$loop.schedule(this.CHANGE_ROW);
    };
    
    this.updateCaret = function() {
        this.$loop.schedule(this.CHANGE_SELECTION);
    };

    /**
     * Triggers a full update of the text, for all the rows.
     **/
    this.updateCells = function() {
        this.$loop.schedule(this.CHANGE_CELLS);
    };

    /**
     * Triggers a full update of all the layers, for all the rows.
     * @param {Boolean} force If `true`, forces the changes through
     *
     *
     **/
    this.updateFull = function(force) {
        if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
        else
            this.$loop.schedule(this.CHANGE_FULL);
    };
    
    this.updateHorizontalHeadings = function(){
        this.$loop.schedule(this.CHANGE_COLUMN);
    };
    
    this.updateVerticalHeadings = function(){
        this.$loop.schedule(this.CHANGE_ROW);
    };

    this.$changes = 0;
    /**
     * [Triggers a resize of the pivot table.]{: #VirtualRenderer.onResize}
     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
     * @param {Number} width The width of the editor in pixels
     * @param {Number} height The height of the editor, in pixels
     **/
    this.onResize = function(force, width, height) {
         if (this.resizing > 2)
            return;
        else if (this.resizing > 0)
            this.resizing++;
        else
            this.resizing = force ? 1 : 0;
        // `|| el.scrollHeight` is required for outosizing editors on ie
        // where elements with clientHeight = 0 alsoe have clientWidth = 0
        var el = this.container;
        if (!height)
            height = el.clientHeight || el.scrollHeight;
        if (!width)
            width = el.clientWidth || el.scrollWidth;
        var changes = this.$updateCachedSize(force, width, height);
        
        // console.log("resizing to", width, height, JSON.stringify(this.$size))

        // setTimeout(function() {
        //     console.log("actual size ", this.container.clientWidth, this.container.clientHeight)
            
        // }.bind(this), 500)
        
        if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;

        if (force)
            this.$renderChanges(changes, true);
        else
            this.$loop.schedule(changes | this.$changes);

        if (this.resizing)
            this.resizing = 0;
    };
    
    this.$updateCachedSize = function(force, width, height) {
        var changes = 0;
        var size = this.$size;
        var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
        };
        if (height && (force || size.height != height)) {
            size.height = height;
            changes = this.CHANGE_SIZE;

            var headingHeight = this.$horHeadingLayer.element.offsetHeight;
            this.$verheading.style.top = 
            this.scroller.style.top    = 
            this.scrollBarV.element.style.top = 
            this.cover.style.height    = headingHeight + "px";
            
            size.scrollerHeight = size.height - headingHeight;
            if (this.$horizScroll) {
                size.scrollerHeight -= this.scrollBarH.getHeight();
            }
            this.scrollBarV.element.style.bottom = 
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
            this.scrollBarV.setHeight(size.scrollerHeight);

            this.setScrollTop(this.getScrollTop());
            changes = changes | this.CHANGE_FULL;
        }

        if (width && (force || size.width != width)) {
            changes = this.CHANGE_SIZE;
            size.width = width;

            var headingWidth = this.$verHeadingLayer.element.offsetWidth;
            this.$horheading.style.left = 
            this.scroller.style.left = 
            this.scrollBarH.element.style.left = 
            this.cover.style.width = headingWidth + "px";
            
            size.scrollerWidth = Math.max(0, width - headingWidth - this.scrollBarV.getWidth());
            this.$horheading.style.right = 
            this.scrollBarH.element.style.right = 
            this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            
            this.setScrollLeft(this.getScrollLeft());
            changes = changes | this.CHANGE_FULL;
        }
        
        if (changes)
            this._signal("resize", oldSize);

        return changes;
    };


    this.setHorHeadingVisible = function(value){
        this.$horHeadingLayer.visible = value;
        if (this.layerConfig.vRange && this.layerConfig.hRange) {
            this.$renderChanges(this.CHANGE_FULL, true);
            this.onResize(true);
        }
    }
    this.setVerHeadingVisible = function(value){
        this.$verHeadingLayer.visible = value;
        if (this.layerConfig.vRange && this.layerConfig.hRange) {
            this.$renderChanges(this.CHANGE_FULL, true);
            this.onResize(true);
        }
    }
    this.setAlignment = function(vertical, index, type){
        (vertical ? this.$verHeadingLayer : this.$horHeadingLayer)
            .setAlignment(index, type);
        if (this.layerConfig.vRange && this.layerConfig.hRange)
            this.$renderChanges(this.CHANGE_CELLS, true);
    }
    this.setDefaultAlignment = function(type, vtype){
        this.$cellLayer.setDefaultAlignment(type, vtype);
        if (this.layerConfig.vRange && this.layerConfig.hRange)
            this.$renderChanges(this.CHANGE_CELLS, true);
    }

    /**
     *
     * Returns the root element containing this renderer.
     * @returns {DOMElement}
     **/
    this.getContainerElement = function() {
        return this.container;
    };

    /**
     *
     * Returns the element that the mouse events are attached to
     * @returns {DOMElement}
     **/
    this.getMouseEventTarget = function() {
        return this.cells;
    };

    /**
     *
     * [Returns the index of the first visible row.]{: #VirtualRenderer.getFirstVisibleRow}
     * @returns {Number}
     **/
    this.getFirstVisibleRow = function() {
        return this.layerConfig.firstRow;
    };

    /**
     *
     * Returns the index of the first fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    this.getFirstFullyVisibleRow = function() {
        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
    };

    /**
     *
     * Returns the index of the last fully visible row. "Fully" here means that the characters in the row are not truncated; that the top and the bottom of the row are on the screen.
     * @returns {Number}
     **/
    this.getLastFullyVisibleRow = function() {
        var range  = this.layerConfig.vRange;
        var config = this.layerConfig;
        var total = -1 * config.vOffset;
        
        var i = 0;
        while (total < config.height) total += range[i++].size;
            
        return range.index + i - 2;
    };

    /**
     *
     * [Returns the index of the last visible row.]{: #VirtualRenderer.getLastVisibleRow}
     * @returns {Number}
     **/
    this.getLastVisibleRow = function() {
        return this.layerConfig.lastRow;
    };
    
    this.$updateScrollBar = function() {
        
        // todo separate event for h v scroll
        this.$updateScrollBarH();
        this.$updateScrollBarV();
    };
    
    this.setScrollMargin = function(top, bottom, left, right) {
        var sm = this.scrollMargin;
        sm.top = top|0;
        sm.bottom = bottom|0;
        sm.right = right|0;
        sm.left = left|0;
        sm.v = sm.top + sm.bottom;
        sm.h = sm.left + sm.right;
        this.updateFull();
    };
    this.$updateScrollBarV = function() {
        this.scrollBarV.setInnerHeight(this.layerConfig.maxHeight + this.scrollMargin.v);
        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
    };
    this.$updateScrollBarH = function() {
        this.scrollBarH.setInnerWidth(this.layerConfig.maxWidth + this.scrollMargin.h);
        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
    };

    this.$renderChanges = function(changes, force) {
        if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
        }
        if ((!this.provider || this.provider.ready === false || !this.container.offsetWidth) || (!changes && !force)) {
            this.$changes |= changes;
            return; 
        } 
        if (!this.$size.width) {
            this.$changes |= changes;
            return this.onResize(true);
        }
            
        // this.$logChanges(changes);
        
        this._signal("beforeRender");
        // text, scrolling and resize changes can cause the view port size to change
        if (changes & this.CHANGE_FULL ||
            changes & this.CHANGE_SIZE ||
            changes & this.CHANGE_SCROLL ||
            changes & this.CHANGE_H_SCROLL ||
            changes & this.CHANGE_COLUMN ||
            changes & this.CHANGE_ROW ||
            changes & this.CHANGE_CELLS
        )
            this.$computeLayerConfig();
        
        // full
        if (changes & this.CHANGE_FULL) {
            // update scrollbar first to not lose scroll position when gutter calls resize
            this.$updateScrollBar();
            this.$horHeadingLayer.update(this.layerConfig);
            this.$verHeadingLayer.update(this.layerConfig);
            this.$cellLayer.update(this.layerConfig);
            this.$selectionLayer.update(this.layerConfig);
            this._signal("afterRender");
            return;
        }

        // scrolling
        if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_ROW || 
                changes & this.CHANGE_COLUMN ||
                changes & this.CHANGE_CELLS
            ) {
                this.$horHeadingLayer.update(this.layerConfig);
                this.$verHeadingLayer.update(this.layerConfig);
                this.$cellLayer.update(this.layerConfig);
            }
            else {
                this.$horHeadingLayer.scroll(this.layerConfig);
                this.$verHeadingLayer.scroll(this.layerConfig);
                this.$cellLayer.scroll(this.layerConfig);
            }

            this.$selectionLayer.update(this.layerConfig);
            this.$updateScrollBar();
            this._signal("afterRender");
            return;
        }
        
        if (changes & this.CHANGE_SELECTION)
            this.$selectionLayer.update(this.layerConfig);

        if (changes & this.CHANGE_ROW)
            this.$verHeadingLayer.update(this.layerConfig);
            // this.$updateRows();
        //@todo analog to updateRows?
        if (changes & this.CHANGE_COLUMN)
            this.$horHeadingLayer.update(this.layerConfig);
        if (changes & this.CHANGE_CELLS)
            this.$cellLayer.update(this.layerConfig);

        if (changes & this.CHANGE_SIZE)
            this.$updateScrollBar();

        this._signal("afterRender");
    };

    
    this.$autosize = function(height, width) {
        var height = this.session.getScreenLength() * this.lineHeight;
        var maxHeight = this.$maxLines * this.lineHeight;
        var desiredHeight = Math.max(
            (this.$minLines||1) * this.lineHeight,
            Math.min(maxHeight, height)
        );
        var vScroll = height > maxHeight;
        
        if (desiredHeight != this.desiredHeight ||
            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, w, desiredHeight);
            // this.$loop.changes = 0;
            this.desiredHeight = desiredHeight;
        }
    };
    
    this.$computeLayerConfig = function() {
        if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();

        var provider   = this.provider;
        var vertical   = this.$verHeadingLayer;
        var horizontal = this.$horHeadingLayer;
        
        var vRange = vertical.getRange(this.scrollTop, this.scrollTop + this.$size.height);
        var hRange = horizontal.getRange(this.scrollLeft, this.scrollLeft + this.$size.width);

        var vOffset   = this.scrollTop - vRange.size;
        var minHeight = this.$size.scrollerHeight;
        var maxHeight = vertical.size;
        
        var hOffset   = this.scrollLeft - hRange.size;
        var minWidth  = this.$size.scrollerWidth;
        var maxWidth  = horizontal.size;

        var hideScrollbars = this.$size.height <= 2 * 10;
        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
            this.$size.scrollerWidth - maxWidth < 0);

        var hScrollChanged = this.$horizScroll !== horizScroll;
        if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
        }
        
        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
            this.$size.scrollerHeight - maxHeight < 0);
        var vScrollChanged = this.$vScroll !== vScroll;
        if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
        }
        
        this.setScrollTop(Math.max(-this.scrollMargin.top,
            Math.min(this.scrollTop, maxHeight - this.$size.scrollerHeight + this.scrollMargin.v)));

        this.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, 
            maxWidth - this.$size.scrollerWidth + this.scrollMargin.h)));

        var rowCount = vRange.length;
        var firstRow = vRange.index;
        var lastRow  = firstRow + rowCount - 1;
        
        var colCount = hRange.length;
        var firstCol = hRange.index;
        var lastCol  = firstCol + colCount - 1;

        if (this.layerConfig)
            this.layerConfig.discard = true;
        
        var hTotals = this.layerConfig.hTotals;
        var vTotals = this.layerConfig.vTotals;


        var changes = 0;
        // Horizontal scrollbar visibility may have changed, which changes
        // the client height of the scroller
        if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.$size.width, this.$size.height);
            this._signal("scrollbarVisibilityChanged");
            //if (vScrollChanged)
            //    longestLine = this.$getLongestLine();
        }
        
        this.layerConfig = {
            vTotals : vTotals,
            hTotals : hTotals,
            vRange : vRange,
            hRange : hRange,
            width : minWidth,
            height : minHeight,
            firstRow : firstRow,
            lastRow : lastRow,
            firstCol : firstCol,
            lastCol : lastCol,
            minHeight : minHeight,
            maxHeight : maxHeight,
            minWidth : minWidth,
            maxWidth : maxWidth,
            vOffset : vOffset,
            hOffset : hOffset
        };
        
        var config = this.layerConfig, renderer = this;
        if (vRange) {
            config.view = provider.getDataRange(
                {start: vRange.index, length: vRange.length}, 
                {start: hRange.index, length: hRange.length}, 
                function(err, view, update){
                    if (err) return false; //@todo
                    config.view = view;
                    
                    if (update)
                        renderer.$loop.schedule(renderer.CHANGE_CELLS);
                });
        }

        // For debugging.
        // console.log(JSON.stringify(this.layerConfig));

        this.$verheading.style.marginTop =
        this.cells.style.marginTop  = (-vOffset) + "px";
        this.$horheading.style.marginLeft =
        this.cells.style.marginLeft = (-hOffset) + "px";
        this.cells.style.width = config.width + "px";
        this.cells.style.height = config.height + (vRange[0] ? vRange[0].size : 0) + "px";
        
        return changes;
    };
    
    this.$updateRows = function() {
        var firstRow = this.$changedLines.firstRow;
        var lastRow = this.$changedLines.lastRow;
        this.$changedLines = null;

        var layerConfig = this.layerConfig;

        if (firstRow > layerConfig.lastRow + 1) { return; }
        if (lastRow < layerConfig.firstRow) { return; }

        // if the last row is unknown -> redraw everything
        if (lastRow === Infinity) {
            this.$cellLayer.update(layerConfig);
            this.$verHeadingLayer.update(layerConfig);
            return;
        }

        // else update only the changed rows
        this.$cellLayer.updateRows(layerConfig, firstRow, lastRow);
        this.$verHeadingLayer.updateRows(layerConfig, firstRow, lastRow);
        return true;
    };

    this.scrollSelectionIntoView = function(anchor, lead, offset) {
        // first scroll anchor into view then scroll lead into view
        this.scrollCaretIntoView(anchor, offset);
        this.scrollCaretIntoView(lead, offset);
    };

    /**
     *
     * Scrolls the Caret into the first visible area of the editor
     **/
    this.scrollCaretIntoView = function(caret, offset) {
        // the editor is not visible
        if (this.$size.scrollerHeight === 0)
            return;

        if (!caret) 
            caret = this.provider.selection.getCaret();
        
        if (!this.$verHeadingLayer.findNodeByIndex(caret.row))
            return;
        
        var left   = this.$horHeadingLayer.findSizeAtIndex(caret.column);
        var width  = this.$horHeadingLayer.findNodeByIndex(caret.column).size;
        var top    = this.$verHeadingLayer.findSizeAtIndex(caret.row);
        var height = this.$verHeadingLayer.findNodeByIndex(caret.row).size;

        if (this.scrollTop > top) {
            if (offset)
                top -= offset * this.$size.scrollerHeight;
            this.setScrollTop(top);
        } else if (this.scrollTop + this.$size.scrollerHeight < top + height) {
            if (offset)
                top += offset * this.$size.scrollerHeight;
            this.setScrollTop(top + height - this.$size.scrollerHeight);
        }

        var scrollLeft = this.scrollLeft;

        if (scrollLeft > left) {
            if (left < 0)
                left = 0;
            this.setScrollLeft(left);
        } else if (scrollLeft + this.$size.scrollerWidth < left + width) {
            this.setScrollLeft(Math.round(left + width - this.$size.scrollerWidth));
        }
    };

    /**
     * @returns {Number}
     **/
    this.getScrollTop = function() {
        return this.scrollTop;
    };

    /**
     * @returns {Number}
     **/
    this.getScrollLeft = function() {
        return this.scrollLeft;
    };
    
    /**
     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
     * @param {Number} scrollTop The new scroll top value
     *
     **/
    this.setScrollTop = function(scrollTop) {
        var config = this.layerConfig;
        var max    = Math.max(0, config.maxHeight - config.minHeight);
        
        scrollTop = Math.round(Math.min(Math.max(0, scrollTop), max));
        if (this.scrollTop === scrollTop || isNaN(scrollTop))
            return;

        this.scrollToY(scrollTop);
    };
    
    /**
     * This function sets the scroll top value. It also emits the `'changeScrollTop'` event.
     * @param {Number} scrollTop The new scroll top value
     *
     **/
    this.setScrollLeft = function(scrollLeft) {
        var config = this.layerConfig;
        var max    = Math.max(0, config.maxWidth - config.minWidth);
        
        scrollLeft = Math.round(Math.min(Math.max(0, scrollLeft), max));
        if (this.scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.scrollToX(scrollLeft);
    };

    /**
     *
     * Returns the first visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    this.getScrollTopRow = function() {
        return this.layerConfig.firstRow;
    };

    /**
     *
     * Returns the last visible row, regardless of whether it's fully visible or not.
     * @returns {Number}
     **/
    this.getScrollBottomRow = function() {
        return this.layerConfig.lastRow;
        //return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
    };

    this.alignCaret = function(cursor, alignment) {
        if (typeof cursor == "number")
            cursor = {row: cursor, column: 0};

        var node = this.$verHeadingLayer.findNodeByIndex(cursor.row);
        var pos = this.$verHeadingLayer.findSizeAtIndex(cursor.row);
        var h = this.$size.scrollerHeight;
        var offset = pos - ((h - node.size) * (alignment || 0));

        this.setScrollTop(offset);
        return offset;
    };

    this.STEPS = 8;
    this.$calcSteps = function(fromValue, toValue){
        var i = 0;
        var l = this.STEPS;
        var steps = [];

        var func  = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
        };

        for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));

        return steps;
    };

    /**
     * Gracefully scrolls the editor to the row indicated.
     * @param {Number} line A line number
     * @param {Boolean} center If `true`, centers the editor the to indicated line
     * @param {Boolean} animate If `true` animates scrolling
     * @param {Function} callback Function to be called after the animation has finished
     *
     *
     **/
    this.scrollToRow = function(row, center, animate, callback) {
        var node = this.$verHeadingLayer.findNodeByIndex(row);
        var offset = this.$verHeadingLayer.findSizeAtIndex(row)
        if (center)
            offset -= (this.$size.scrollerHeight - node.size) / 2;

        var initialScroll = this.scrollTop;
        this.setScrollTop(offset);
        if (animate !== false)
            this.animateScrolling(initialScroll, callback);
    };

    this.animateScrolling = function(fromValue, callback) {
        var toValue = this.scrollTop;
        if (this.$animatedScroll && Math.abs(fromValue - toValue) < 100000) {
            var _self = this;
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$inScrollAnimation = true;

            clearInterval(this.$timer);

            _self.session.setScrollTop(steps.shift());
            this.$timer = setInterval(function() {
                if (steps.length) {
                    _self.setScrollTop(steps.shift());
                    // trick session to think it's already scrolled to not loose toValue
                    _self.scrollTop = toValue;
                } else if (toValue != null) {
                    _self.scrollTop = -1;
                    _self.setScrollTop(toValue);
                    toValue = null;
                } else {
                    // do this on separate step to not get spurious scroll event from scrollbar
                    _self.$timer = clearInterval(_self.$timer);
                    _self.$inScrollAnimation = false;
                    callback && callback();
                }
            }, 10);
        }
    };

    /**
     * Scrolls the editor to the y pixel indicated.
     * @param {Number} scrollTop The position to scroll to
     *
     *
     * @returns {Number}
     **/
    this.scrollToY = function(scrollTop) {
        // after calling scrollBar.setScrollTop
        // scrollbar sends us event with same scrollTop. ignore it
        if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
        }
    };

    /**
     * Scrolls the editor across the x-axis to the pixel indicated.
     * @param {Number} scrollLeft The position to scroll to
     *
     *
     * @returns {Number}
     **/
    this.scrollToX = function(scrollLeft) {
        if (scrollLeft < 0)
            scrollLeft = 0;

        if (this.scrollLeft !== scrollLeft) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollLeft = scrollLeft;
        }
    };

    /**
     * Scrolls the editor across both x- and y-axes.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     *
     *
     **/
    this.scrollBy = function(deltaX, deltaY) {
        deltaY && this.setScrollTop(this.getScrollTop() + deltaY);
        deltaX && this.setScrollLeft(this.getScrollLeft() + deltaX);
    };

    /**
     * Returns `true` if you can still scroll by either parameter; in other words, you haven't reached the end of the file or line.
     * @param {Number} deltaX The x value to scroll by
     * @param {Number} deltaY The y value to scroll by
     *
     *
     * @returns {Boolean}
     **/
    this.isScrollableBy = function(deltaX, deltaY) {
        if (deltaY < 0 && this.getScrollTop() >= 1)
           return true;
        if (deltaY > 0 && this.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1)
           return true;
        if (deltaX < 0 && this.getScrollLeft() >= 1)
           return true;
        if (deltaX > 0 && this.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.maxWidth < -1)
           return true;
    };

    // @todo this code can be compressed
    this.screenToTextCoordinates = function(x, y) {
        var canvasPos = this.scroller.getBoundingClientRect();

        var config = this.layerConfig;
        var total, i, range;
        
        total = -1 * config.hOffset, i = 0, x -= canvasPos.left;
        if (x > 0) {
            range = this.$horHeadingLayer.getRange(this.scrollLeft, this.scrollLeft + x);
            i = 0;
            while (total < x) {
                if (!range[i]) break;
                total += range[i++].size;
            }
            i -= 1;
        }
        else {
            range = this.$horHeadingLayer.getRange(this.scrollLeft + x, this.scrollLeft);
            i = range.length - 1;
            while (total > x) {
                if (!range[i]) { i++; break; }
                total -= range[i--].size;
            }
        }
        var col = range.index + i;
        
        total = -1 * config.vOffset, y -= canvasPos.top;
        if (y > 0) {
            range = this.$verHeadingLayer.getRange(this.scrollTop, this.scrollTop + y);
            i = 0;
            while (total < y) {
                if (!range[i]) break;
                total += range[i++].size;
            }
            i -= 1;
        }
        else {
            range = this.$verHeadingLayer.getRange(this.scrollTop + y, this.scrollTop);
            i = range.length - 1;
            while (total > y) {
                if (!range[i]) { i++; break; }
                total -= range[i--].size;
            }
        }
        var row = range.index + i;

        return {
            row : row,
            column : col
        }
    };

    /**
     * Returns an object containing the `pageX` and `pageY` coordinates of the document position.
     * @param {Number} row The document row position
     * @param {Number} column The document column position
     *
     *
     *
     * @returns {Object}
     **/
    this.textToScreenCoordinates = function(row, column) {
        throw new Error();
//         var canvasPos = this.scroller.getBoundingClientRect();
//         var pos = this.session.documentToScreenPosition(row, column);
// 
//         var x = this.$padding + Math.round(pos.column * this.characterWidth);
//         var y = pos.row * this.lineHeight;
// 
//         return {
//             pageX: canvasPos.left + x - this.scrollLeft,
//             pageY: canvasPos.top + y - this.scrollTop
//         };
    };
    
    this.$moveTextAreaToCursor = function(){};

    /**
     *
     * Focuses the current container.
     **/
    this.visualizeFocus = function() {
        dom.addCssClass(this.container, "pivot_focus");
    };

    /**
     *
     * Blurs the current container.
     **/
    this.visualizeBlur = function() {
        dom.removeCssClass(this.container, "pivot_focus");
    };

    // Methods allows to add / remove CSS classnames to the editor element.
    // This feature can be used by plug-ins to provide a visual indication of
    // a certain mode that editor is in.

    /**
     * [Adds a new class, `style`, to the editor.]{: #VirtualRenderer.setStyle}
     * @param {String} style A class name
     *
     *
     **/
    this.setStyle = function setStyle(style, include) {
        dom.setCssClass(this.container, style, include != false);
    };

    /**
     * [Removes the class `style` from the editor.]{: #VirtualRenderer.unsetStyle}
     * @param {String} style A class name
     *
     *
     **/
    this.unsetStyle = function unsetStyle(style) {
        dom.removeCssClass(this.container, style);
    };

    /**
     *
     * Destroys the text and Caret layers for this renderer.
     **/
    this.destroy = function() {
        this.$cellLayer.destroy();
        this.$CaretLayer.destroy();
    };

}).call(VirtualRenderer.prototype);

config.defineOptions(VirtualRenderer.prototype, "renderer", {
    animatedScroll: {initialValue: false},
    showInvisibles: {
        set: function(value) {
            if (this.$cellLayer.setShowInvisibles(value))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
    },
    showPrintMargin: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: true
    },
    printMarginColumn: {
        set: function() { this.$updatePrintMargin(); },
        initialValue: 80
    },
    printMargin: {
        set: function(val) {
            if (typeof val == "number")
                this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
        },
        get: function() {
            return this.$showPrintMargin && this.$printMarginColumn; 
        }
    },
    showGutter: {
        set: function(show){
            this.$gutter.style.display = show ? "block" : "none";
            this.onGutterResize();
        },
        initialValue: true
    },
    fadeFoldWidgets: {
        set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
    },
    showFoldWidgets: {
        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},
        initialValue: true
    },
    displayIndentGuides: {
        set: function(show) {
            if (this.$cellLayer.setDisplayIndentGuides(show))
                this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
    },
    highlightGutterLine: {
        set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
                this.$gutterLineHighlight = dom.createElement("div");
                this.$gutterLineHighlight.className = "ace_gutter-active-line";
                this.$gutter.appendChild(this.$gutterLineHighlight);
                return;
            }

            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            // if Caretlayer have never been updated there's nothing on screen to update
            if (this.$CaretLayer.$pixelPos)
                this.$updateGutterLineHighlight();
        },
        initialValue: false,
        value: true
    },
    hScrollBarAlwaysVisible: {
        set: function(alwaysVisible) {
            this.$hScrollBarAlwaysVisible = alwaysVisible;
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
    },
    fontSize:  {
        set: function(size) {
            if (typeof size == "number")
                size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
        },
        initialValue: 12
    },
    fontFamily: {
        set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
        }
    }
});

exports.VirtualRenderer = VirtualRenderer;
});
