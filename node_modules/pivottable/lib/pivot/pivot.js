/**
 * The main class required to set up a Pivot instance in the browser.
 *
 * @class Pivot
 **/

define(function(require, exports, module) {
"use strict";

// var UndoManager = require("./undomanager").UndoManager;
var Renderer = require("./virtual_renderer").VirtualRenderer;
// var MultiSelect = require("./multi_select").MultiSelect;

exports.config = require("./config");

var oop = require("./lib/oop");
var useragent = require("./lib/useragent");
var TextInput = require("./keyboard/textinput").TextInput;
var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
var KeyBinding = require("./keyboard/keybinding").KeyBinding;
var Selection = require("./selection").Selection;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var CommandManager = require("./commands/command_manager").CommandManager;
var defaultCommands = require("./commands/default_commands").commands;
var config = require("./config");

/**
 * @class Editor
 **/

/**
 * Creates a new `Pivot` object.
 * @param {Object} element The html element the pivot table renders in.
 *
 *
 * @constructor
 **/
var Pivot = function(element, cellWidth, cellHeight) {
    this.cellWidth  = cellWidth || 80;
    this.cellHeight = cellHeight || 24;
    
    this.renderer = new Renderer(element, this.cellWidth, this.cellHeight);
    this.container = this.renderer.container;

    this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
    this.textInput  = new TextInput(this.container, this);
    this.keyBinding = new KeyBinding(this);

    // TODO detect touch event support
    this.$mouseHandler = new MouseHandler(this);

    this.$blockScrolling = 0;
    
    var _self = this;
    this.renderer.on("edit", function(e){
        _self._emit("edit", e);
    });

    config.resetOptions(this);
    config._emit("pivot", this);
};

(function(){

    oop.implement(this, EventEmitter);

    /**
     *
     **/
    this.setDataProvider = function(provider) {
        if (this.provider) {
            var oldProvider = this.provider;
            if (this.provider.off) {
                // this.session.off("changeScrollLeft", this.$onScrollLeftChange);
                this.provider.off("updateModel", this.$onModelChange);
    
                this.selection.off("changeCaret", this.$onCaretChange);
                this.selection.off("changeSelection", this.$onSelectionChange);
            }
        }

        this.provider = provider;
        
        this.renderer.setDataProvider(provider);

        // this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
        // this.session.on("changeScrollLeft", this.$onScrollLeftChange);

        this.selection = new Selection(this);
        this.provider.selection = this.selection;
        
        this.$onCaretChange = this.onCaretChange.bind(this);
        this.selection.on("changeCaret", this.$onCaretChange);

        this.$onSelectionChange = this.onSelectionChange.bind(this);
        this.selection.on("changeSelection", this.$onSelectionChange);
      
        this.$onModelChange = this.onModelChange.bind(this);
        if (this.provider.on)
            this.provider.on("updateModel", this.$onModelChange);
        
        this.$blockScrolling += 1;
        this.onCaretChange();
        this.$blockScrolling -= 1;

        this.onScrollTopChange();
        this.onScrollLeftChange();
        this.onSelectionChange();
        this.renderer.updateFull();

        this._emit("changeDataProvider", {
            provider: provider,
            oldProvider: oldProvider
        });
    };
    
    this.getLength = function(){
        return this.renderer.$verHeadingLayer.length;
    };
    
    this.getLine = function(row){
        return {
            length : this.renderer.$horHeadingLayer.length - 1
        }
    };

    /**
     * Returns the current session being used.
     **/
    this.getDataProvider = function() {
        return this.provider;
    };

    /**
     *
     * Returns the currently highlighted selection.
     * @returns {String} The highlighted selection
     **/
    this.getSelection = function() {
        return this.selection;
    };

    /**
     * {:VirtualRenderer.onResize}
     * @param {Boolean} force If `true`, recomputes the size, even if the height and width haven't changed
     *
     *
     * @related VirtualRenderer.onResize
     **/
    this.resize = function(force) {
        this.renderer.onResize(force);
    };

    /**
     *
     * Brings the current `textInput` into focus.
     **/
    this.focus = function() {
        // Safari needs the timeout
        // iOS and Firefox need it called immediately
        // to be on the save side we do both
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    };

    /**
     * Returns `true` if the current `textInput` is in focus.
     * @return {Boolean}
     **/
    this.isFocused = function() {
        return this.textInput.isFocused();
    };

    /**
     *
     * Blurs the current `textInput`.
     **/
    this.blur = function() {
        this.textInput.blur();
    };

    /**
     * Emitted once the editor comes into focus.
     * @event focus
     *
     *
     **/
    this.onFocus = function() {
        if (this.$isFocused)
            return;
        this.$isFocused = true;
        this.renderer.visualizeFocus();
        this._emit("focus");
    };

    /**
     * Emitted once the editor has been blurred.
     * @event blur
     *
     *
     **/
    this.onBlur = function() {
        if (!this.$isFocused)
            return;
        this.$isFocused = false;
        this.renderer.visualizeBlur();
        this._emit("blur");
    };

    this.onScrollTopChange = function() {
        this.renderer.scrollToY(this.renderer.getScrollTop());
    };

    this.onScrollLeftChange = function() {
        this.renderer.scrollToX(this.renderer.getScrollLeft());
    };
    
    this.onModelChange = function() {
        this.renderer.setDataProvider(this.provider);
        this.renderer.updateFull();
    };
    
    this.$caretChange = function() {
        this.renderer.updateCaret();
    };

    /**
     * Emitted when the selection changes.
     *
     **/
    this.onCaretChange = function() {
        this.$caretChange();

        if (!this.$blockScrolling)
            this.renderer.scrollCaretIntoView();

        this._emit("changeSelection");
    };
    
    this.onSelectionChange = function(e) {
        this.onCaretChange();
    };

    this.execCommand = function(command, args) {
        this.commands.exec(command, this, args);
    };

    this.onTextInput = function(text) {
        this.keyBinding.onTextInput(text);
    };

    this.onCommandKey = function(e, hashId, keyCode) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    };

    this.insertEntityOption = function(name, option){};
    this.removeEntityOption = function(name, option){};

    /**
     * Returns an object indicating the currently selected rows. The object looks like this:
     *
     * ```json
     * { first: range.start.row, last: range.end.row }
     * ```
     *
     * @returns {Object}
     **/
    this.$getSelectedRows = function() {
        var range = this.getSelectionRange().collapseRows();

        return {
            first: range.start.row,
            last: range.end.row
        };
    };

    /**
     * {:VirtualRenderer.getFirstVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getFirstVisibleRow
     **/
    this.getFirstVisibleRow = function() {
        return this.renderer.getFirstVisibleRow();
    };

    /**
     * {:VirtualRenderer.getLastVisibleRow}
     *
     * @returns {Number}
     * @related VirtualRenderer.getLastVisibleRow
     **/
    this.getLastVisibleRow = function() {
        return this.renderer.getLastVisibleRow();
    };

    /**
     * Indicates if the row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     * @returns {Boolean}
     **/
    this.isRowVisible = function(row) {
        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
    };

    /**
     * Indicates if the entire row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     *
     * @returns {Boolean}
     **/
    this.isRowFullyVisible = function(row) {
        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
    };

    /**
     * Returns the number of currently visibile rows.
     * @returns {Number}
     **/
    this.$getVisibleRowCount = function() {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    };
    
    this.$moveByPage = function(dir, select) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        
        var caret = this.selection.getCaret();
        var heading = this.renderer.$verHeadingLayer;
        var start, range, rows, toScrollTop;
        
        // Window ends at new cursor position
        if (dir > 0) {
            var lastRow = Math.min(config.lastRow, 
                this.renderer.getLastFullyVisibleRow() + 1);
            
            if (caret.row == heading.length - 1)
                return;
            
            if (caret.row >= lastRow) {
                start = config.vRange.size + config.height;
                range = heading.getRange(start, start + config.height);
                rows  = range.length + range.index - caret.row - 1;
            }
            else {
                var size = heading.findSizeAtIndex(lastRow + 1);
                range = heading.getRange(size - config.height, size);
                rows = lastRow - caret.row;
            }
        }
        // Window starts at new cursor position
        else {
            var firstRow = Math.max(config.firstRow, 
                this.renderer.getFirstFullyVisibleRow() - 1);
            
            if (caret.row == 0)
                return;
            
            if (caret.row <= firstRow) {
                start = config.vRange.size - config.height;
                range = heading.getRange(start, start + config.height);
                rows  = range.index - caret.row;
            }
            else {
                var size = heading.findSizeAtIndex(firstRow);
                range = heading.getRange(size, size + config.height);
                rows = firstRow - caret.row;
            }
        }
        
        this.$blockScrolling++;
        if (select == true) {
            this.selection.$moveSelection(function(){
                this.moveCaretBy(rows, 0);
            });
        } else if (select == false) {
            this.selection.moveCaretBy(rows, 0);
            this.selection.clearSelection();
        }
        this.$blockScrolling--;

        var scrollTop = renderer.scrollTop;
        
        caret = this.selection.getCaret();
        toScrollTop = dir > 0
            ? heading.findSizeAtIndex(Math.min(heading.length - 1, caret.row + 1)) - config.height 
            : heading.findSizeAtIndex(caret.row);
            
        renderer.setScrollTop(toScrollTop);
        if (select != null)
            renderer.scrollCaretIntoView(null, 0.5);

        renderer.animateScrolling(scrollTop);
    };

    /**
     * Selects the text from the current position of the document until where a "page down" finishes.
     **/
    this.selectPageDown = function() {
        this.$moveByPage(1, true);
    };

    /**
     * Selects the text from the current position of the document until where a "page up" finishes.
     **/
    this.selectPageUp = function() {
        this.$moveByPage(-1, true);
    };

    /**
     * Shifts the document to wherever "page down" is, as well as moving the cursor position.
     **/
    this.gotoPageDown = function() {
       this.$moveByPage(1, false);
    };

    /**
     * Shifts the document to wherever "page up" is, as well as moving the cursor position.
     **/
    this.gotoPageUp = function() {
        this.$moveByPage(-1, false);
    };

    /**
     * Scrolls the document to wherever "page down" is, without changing the cursor position.
     **/
    this.scrollPageDown = function() {
        this.$moveByPage(1);
    };

    /**
     * Scrolls the document to wherever "page up" is, without changing the cursor position.
     **/
    this.scrollPageUp = function() {
        this.$moveByPage(-1);
    };

    /**
     * Scrolls to a row. If `center` is `true`, it puts the row in middle of screen (or attempts to).
     * @param {Number} row The row to scroll to
     * @param {Boolean} center If `true`
     * @param {Boolean} animate If `true` animates scrolling
     * @param {Function} callback Function to be called when the animation has finished
     *
     *
     * @related VirtualRenderer.scrollToRow
     **/
    this.scrollToRow = function(row, center, animate, callback) {
        this.renderer.scrollToRow(row, center, animate, callback);
    };

    /**
     * Attempts to center the current selection on the screen.
     **/
    this.centerSelection = function() {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        }
        this.renderer.alignCaret(pos, 0.5);
    };

    /**
     * Gets the current position of the Caret.
     * @returns {Object} An object that looks something like this:
     *
     * ```json
     * { row: currRow, column: currCol }
     * ```
     *
     * @related Selection.getCaret
     **/
    this.getCaretPosition = function() {
        return this.selection.getCaret();
    };

    /**
     * Returns the screen position of the Caret.
     * @returns {Number}
     **/
    this.getCaretPositionScreen = function() {
        return this.session.documentToScreenPosition(this.getCaretPosition());
    };

    /**
     * {:Selection.getRange}
     * @returns {Range}
     * @related Selection.getRange
     **/
    this.getSelectionRange = function() {
        return this.selection.getRange();
    };


    /**
     * Selects all the text in editor.
     * @related Selection.selectAll
     **/
    this.selectAll = function() {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    };

    /**
     * {:Selection.clearSelection}
     * @related Selection.clearSelection
     **/
    this.clearSelection = function() {
        this.selection.clearSelection();
    };

    /**
     * Moves the Caret to the specified row and column. Note that this does not de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     *
     * @related Selection.moveCaretTo
     **/
    this.moveCaretTo = function(row, column) {
        this.selection.moveCaretTo(row, column);
    };

    /**
     * Moves the Caret to the position indicated by `pos.row` and `pos.column`.
     * @param {Object} pos An object with two properties, row and column
     *
     *
     * @related Selection.moveCaretToPosition
     **/
    this.moveCaretToPosition = function(pos) {
        this.selection.moveCaretToPosition(pos);
    };

    /**
     * Moves the Caret to the specified row number, and also into the indiciated column.
     * @param {Number} rowNumber The row number to go to
     * @param {Number} column A column number to go to
     * @param {Boolean} animate If `true` animates scolling
     *
     **/
    this.gotoRow = function(rowNumber, column, animate) {
        this.selection.clearSelection();
        
        if (column === undefined)
            column = this.selection.getCaret().column;

        this.$blockScrolling += 1;
        this.moveCaretTo(rowNumber - 1, column || 0);
        this.$blockScrolling -= 1;

        if (!this.isRowFullyVisible(rowNumber - 1))
            this.scrollToRow(rowNumber - 1, true, animate);
    };

    /**
     * Moves the Caret to the specified row and column. Note that this does de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     *
     * @related Editor.moveCaretTo
     **/
    this.navigateTo = function(row, column) {
        this.clearSelection();
        this.moveCaretTo(row, column);
    };

    /**
     * Moves the Caret up in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateUp = function(times) {
        this.selection.clearSelection();
        times = times || 1;
        this.selection.moveCaretBy(-times, 0);
    };

    /**
     * Moves the Caret down in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateDown = function(times) {
        this.selection.clearSelection();
        times = times || 1;
        this.selection.moveCaretBy(times, 0);
    };

    /**
     * Moves the Caret left in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateLeft = function(times) {
        times = times || 1;
        while (times--) {
            this.selection.moveCaretLeft();
        }
        this.clearSelection();
    };

    /**
     * Moves the Caret right in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    this.navigateRight = function(times) {
        times = times || 1;
        while (times--) {
            this.selection.moveCaretRight();
        }
        this.clearSelection();
    };

    /**
     *
     * Moves the Caret to the start of the current row. Note that this does de-select the current selection.
     **/
    this.navigateRowStart = function() {
        this.selection.moveCaretRowStart();
        this.clearSelection();
    };

    /**
     *
     * Moves the Caret to the end of the current row. Note that this does de-select the current selection.
     **/
    this.navigateRowEnd = function() {
        this.selection.moveCaretRowEnd();
        this.clearSelection();
    };

    /**
     *
     * Moves the Caret to the end of the current file. Note that this does de-select the current selection.
     **/
    this.navigateFileEnd = function() {
        var scrollTop = this.renderer.scrollTop;
        this.selection.moveCaretFileEnd();
        this.clearSelection();
        this.renderer.animateScrolling(scrollTop);
    };

    /**
     *
     * Moves the Caret to the start of the current file. Note that this does de-select the current selection.
     **/
    this.navigateFileStart = function() {
        var scrollTop = this.renderer.scrollTop;
        this.selection.moveCaretFileStart();
        this.clearSelection();
        this.renderer.animateScrolling(scrollTop);
    };

    this.revealRange = function(range, animate) {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate != false)
            this.renderer.animateScrolling(scrollTop);
    };

    /**
     * {:UndoManager.undo}
     * @related UndoManager.undo
     **/
    this.undo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCaretIntoView(null, 0.5);
    };

    /**
     * {:UndoManager.redo}
     * @related UndoManager.redo
     **/
    this.redo = function() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCaretIntoView(null, 0.5);
    };
    
    /**
     * Returns `true` if the editor is set to read-only mode.
     * @returns {Boolean}
     **/
    this.getReadOnly = function() {
        return this.getOption("readOnly");
    };

    /**
     *
     * Cleans up the entire editor.
     **/
    this.destroy = function() {
        this.renderer.destroy();
        this._emit("destroy", this);
    };
    
    this.setHorHeadingVisible = function(value){
        this.renderer.setHorHeadingVisible(value);
    }
    this.setVerHeadingVisible = function(value){
        this.renderer.setVerHeadingVisible(value);
    }
    this.setAlignment = function(vertical, index, type){
        this.renderer.setAlignment(vertical, index, type);
    }
    this.setDefaultAlignment = function(type, vtype){
        this.renderer.setDefaultAlignment(type, vtype);
    }

    /**
     * Enables automatic scrolling of the Caret into view when editor itself is inside scrollable element
     * @param {Boolean} enable default true
     **/
    this.setAutoScrollEditorIntoView = function(enable) {
        if (enable === false)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = "position:absolute";
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
        });
        // needed to not trigger sync reflow
        var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && self.isFocused()) {
                var renderer = self.renderer;
                var pos = renderer.$CaretLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                    shouldScroll = true;
                } else if (pos.top < config.height &&
                    pos.top + rect.top + config.rowHeight > window.innerHeight) {
                    shouldScroll = false;
                } else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + "px";
                    scrollAnchor.style.left = pos.left + "px";
                    scrollAnchor.style.height = config.rowHeight + "px";
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable === true)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
        };
    };
}).call(Pivot.prototype);

config.defineOptions(Pivot.prototype, "pivot", {
    toggle: {
        set: function(toggle) {
            
        },
        initialValue: false
    },
    readOnly: {
        set: function(readOnly) {
            this.textInput.setReadOnly(readOnly);
        },
        initialValue: false
    },

    animatedScroll: "renderer",

    scrollSpeed: "$mouseHandler"
});

module.exports = Pivot;
});
