/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

define(function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var lang = require("./lib/lang");
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

/**
 * 
 * Contains the cursor position and the text selection of an edit session.
 *
 * The row/columns used in the selection are in document coordinates representing ths coordinates as thez appear in the document before applying soft wrap and folding.
 * @class Selection
 **/


/**
 * Emitted when the cursor position changes.
 * @event changeCaret
 *
 * 
 *
**/
/**
 * Emitted when the cursor selection changes.
 *  @event changeSelection
 *
 * 
 *
**/
/**
 * Creates a new `Selection` object.
 * @param {Pivot} pivot The pivot object that it's applied to
 *
 * 
 * 
 * @constructor
 **/
var Selection = function(pivot) {
    this.pivot = pivot;
    
    this.clearSelection();
    this.lead = this.selectionLead = new Anchor(pivot, 0, 0);
    this.anchor = this.selectionAnchor = new Anchor(pivot, 0, 0);

    var self = this;
    this.lead.on("change", function(e) {
        self._emit("changeCaret");
        if (!self.$isEmpty)
            self._emit("changeSelection");
        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
    });

    this.selectionAnchor.on("change", function() {
        if (!self.$isEmpty)
            self._emit("changeSelection");
    });
};

(function() {

    oop.implement(this, EventEmitter);

    /**
    * 
    * Returns `true` if the selection is empty.
    * @returns {Boolean}
    **/
    this.isEmpty = function() {
        return (this.$isEmpty || (
            this.anchor.row == this.lead.row &&
            this.anchor.column == this.lead.column
        ));
    };

    /** 
    * Returns `true` if the selection is a multi-line.
    * @returns {Boolean}
    **/
    this.isMultiRow = function() {
        if (this.isEmpty()) {
            return false;
        }

        return this.getRange().isMultiLine();
    };

    /** 
    * Gets the current position of the cursor.
    * @returns {Number}
    **/
    this.getCaret = function() {
        return this.lead.getPosition();
    };

    /**
    * Sets the row and column position of the anchor. This function also emits the `'changeSelection'` event.
    * @param {Number} row The new row
    * @param {Number} column The new column
    *
    * 
    **/
    this.setSelectionAnchor = function(row, column) {
        this.anchor.setPosition(row, column);

        if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
        }
    };

    /**
    * Returns an object containing the `row` and `column` of the calling selection anchor.
    *
    * @returns {Object}
    * @related Anchor.getPosition
    **/
    this.getSelectionAnchor = function() {
        if (this.$isEmpty)
            return this.getSelectionLead()
        else
            return this.anchor.getPosition();
    };

    /**
    * 
    * Returns an object containing the `row` and `column` of the calling selection lead.
    * @returns {Object}
    **/
    this.getSelectionLead = function() {
        return this.lead.getPosition();
    };

    /**
    * Shifts the selection up (or down, if [[Selection.isBackwards `isBackwards()`]] is true) the given number of columns.
    * @param {Number} columns The number of columns to shift by
    *
    * 
    *
    **/
    this.shiftSelection = function(columns) {
        if (this.$isEmpty) {
            this.moveCaretTo(this.lead.row, this.lead.column + columns);
            return;
        };

        var anchor = this.getSelectionAnchor();
        var lead = this.getSelectionLead();

        var isBackwards = this.isBackwards();

        if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);

        if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
                this.moveCaretTo(lead.row, lead.column + columns);
            });
        }
    };

    /**
    * Returns `true` if the selection is going backwards in the document.
    * @returns {Boolean}
    **/
    this.isBackwards = function() {
        var anchor = this.anchor;
        var lead = this.lead;
        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
    };

    /**
    * [Returns the [[Range]] for the selected text.]{: #Selection.getRange}
    * @returns {Range}
    **/
    this.getRange = function() {
        var anchor = this.anchor;
        var lead = this.lead;

        if (this.isEmpty())
            return Range.fromPoints(lead, lead);

        if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
        }
        else {
            return Range.fromPoints(anchor, lead);
        }
    };

    /**
    * [Empties the selection (by de-selecting it). This function also emits the `'changeSelection'` event.]{: #Selection.clearSelection}
    **/
    this.clearSelection = function() {
        if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
        }
    };

    /**
    * Selects all the text in the document.
    **/
    this.selectAll = function() {
        var lastRow = this.getRowLength() - 1;
        this.setSelectionAnchor(0, 0);
        this.moveCaretTo(lastRow, this.getColumnLength());
    };

    /**
    * Sets the selection to the provided range.
    * @param {Range} range The range of text to select
    * @param {Boolean} reverse Indicates if the range should go backwards (`true`) or not
    *
    * 
    * @method setSelectionRange
    * @alias setRange
    **/
    this.setRange =
    this.setSelectionRange = function(range, reverse) {
        if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
        } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
        }
        this.$desiredColumn = null;
    };

    this.$moveSelection = function(mover) {
        var lead = this.lead;
        if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);

        mover.call(this);
    };

    /**
    * Moves the selection cursor to the indicated row and column.
    * @param {Number} row The row to select to
    * @param {Number} column The column to select to
    *
    * 
    *
    **/
    this.selectTo = function(row, column) {
        this.$moveSelection(function() {
            this.moveCaretTo(row, column);
        });
    };

    /**
    * Moves the selection cursor to the row and column indicated by `pos`.
    * @param {Object} pos An object containing the row and column
    *
    * 
    *
    **/
    this.selectToPosition = function(pos) {
        this.$moveSelection(function() {
            this.moveCaretToPosition(pos);
        });
    };

    /**
    * 
    * Moves the selection up one row.
    **/
    this.selectUp = function() {
        this.$moveSelection(this.moveCaretUp);
    };

    /**
    * 
    * Moves the selection down one row.
    **/
    this.selectDown = function() {
        this.$moveSelection(this.moveCaretDown);
    };

    /**
    * 
    *
    * Moves the selection right one column.
    **/
    this.selectRight = function() {
        this.$moveSelection(this.moveCaretRight);
    };

    /**
    * 
    * Moves the selection left one column.
    **/
    this.selectLeft = function() {
        this.$moveSelection(this.moveCaretLeft);
    };

    /**
    * 
    * Moves the selection to the beginning of the current line.
    **/
    this.selectRowStart = function() {
        this.$moveSelection(this.moveCaretRowStart);
    };

    /**
    * 
    * Moves the selection to the end of the current line.
    **/
    this.selectRowEnd = function() {
        this.$moveSelection(this.moveCaretRowEnd);
    };

    /**
    * 
    * Moves the selection to the end of the file.
    **/
    this.selectFileEnd = function() {
        this.$moveSelection(this.moveCaretFileEnd);
    };

    /**
    * 
    * Moves the selection to the start of the file.
    **/
    this.selectFileStart = function() {
        this.$moveSelection(this.moveCaretFileStart);
    };


    this.getRowRange = function(row) {
        var rowStart = typeof row == "number" ? row : this.lead.row;
        
        return new Range(rowStart, 0, rowStart, this.getColumnLength());
    };

    /**
    * Selects the entire line.
    **/
    this.selectRow = function() {
        this.setSelectionRange(this.getRowRange());
    };

    /**
    * 
    * Moves the cursor up one row.
    **/
    this.moveCaretUp = function() {
        this.moveCaretBy(-1, 0);
    };

    /**
    * 
    * Moves the cursor down one row.
    **/
    this.moveCaretDown = function() {
        this.moveCaretBy(1, 0);
    };

    /**
    * 
    * Moves the cursor left one column.
    **/
    this.moveCaretLeft = function() {
        var cursor = this.lead.getPosition();

        if (cursor.column == 0) {
            return;
        }
        else {
            this.moveCaretBy(0, -1);
        }
    };
    
    this.getRowLength = function(){
        return this.pivot.renderer.$verHeadingLayer.length;
    };
    
    this.getColumnLength = function(){
        return this.pivot.renderer.$horHeadingLayer.length - 1;
    };

    /**
    * 
    * Moves the cursor right one column.
    **/
    this.moveCaretRight = function() {
        if (this.lead.column == this.getColumnLength()) {
            return;
        }
        else {
            this.moveCaretBy(0, 1);
        }
    };

    /**
    * 
    * Moves the cursor to the start of the line.
    **/
    this.moveCaretRowStart = function() {
        var row = this.lead.row;
        this.moveCaretToPosition({row: row, column: 0});
    };

    /**
    * 
    * Moves the cursor to the end of the line.
    **/
    this.moveCaretRowEnd = function() {
        this.moveCaretTo(this.lead.row, this.getColumnLength());
    };

    /**
    * 
    * Moves the cursor to the end of the file.
    **/
    this.moveCaretFileEnd = function() {
        var row = this.getRowLength() - 1;
        var column = this.getColumnLength();
        this.moveCaretTo(row, column);
    };

    /**
    * 
    * Moves the cursor to the start of the file.
    **/
    this.moveCaretFileStart = function() {
        this.moveCaretTo(0, 0);
    };

    /**
    * Moves the cursor to position indicated by the parameters. Negative numbers move the cursor backwards in the document. 
    * @param {Number} rows The number of rows to move by
    * @param {Number} chars The number of characters to move by
    **/
    this.moveCaretBy = function(rows, columns) {
        // move the cursor and update the desired column
        this.moveCaretTo(this.lead.row + rows, this.lead.column + columns, columns === 0);
    };

    /**
    * Moves the selection to the position indicated by its `row` and `column`.
    * @param {Object} position The position to move to
    *
    * 
    **/
    this.moveCaretToPosition = function(position) {
        this.moveCaretTo(position.row, position.column);
    };

    /**
    * Moves the cursor to the row and column provided. [If `preventUpdateDesiredColumn` is `true`, then the cursor stays in the same column position as its original point.]{: #preventUpdateBoolDesc}
    * @param {Number} row The row to move to
    * @param {Number} column The column to move to
    * @param {Boolean} keepDesiredColumn [If `true`, the cursor move does not respect the previous column]{: #preventUpdateBool}
    *
    * 
    **/
    this.moveCaretTo = function(row, column, keepDesiredColumn) {
        this.$keepDesiredColumnOnChange = true;
        this.lead.setPosition(Math.max(0, row), Math.max(0, column));
        this.$keepDesiredColumnOnChange = false;

        if (!keepDesiredColumn)
            this.$desiredColumn = null;
    };

    /**
    * Moves the cursor to the screen position indicated by row and column. {:preventUpdateBoolDesc}
    * @param {Number} row The row to move to
    * @param {Number} column The column to move to
    * @param {Boolean} keepDesiredColumn {:preventUpdateBool}
    *
    * 
    **/
    this.moveCaretToScreen = function(row, column, keepDesiredColumn) {
        var pos = this.session.screenToDocumentPosition(row, column);
        this.moveCaretTo(pos.row, pos.column, keepDesiredColumn);
    };

    // remove listeners from document
    this.detach = function() {
        this.lead.detach();
        this.anchor.detach();
        this.session = this.doc = null;
    };

    this.fromOrientedRange = function(range) {
        this.setSelectionRange(range, range.cursor == range.start);
        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
    };

    this.toOrientedRange = function(range) {
        var r = this.getRange();
        if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
        } else {
            range = r;
        }

        range.cursor = this.isBackwards() ? range.start : range.end;
        range.desiredColumn = this.$desiredColumn;
        return range;
    };

}).call(Selection.prototype);

exports.Selection = Selection;
});
