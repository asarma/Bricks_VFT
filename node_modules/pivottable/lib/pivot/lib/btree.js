define(function(require, exports, module) {

function BTree(maxChilds){
    this.maxChilds = maxChilds;
    this.minChilds = Math.floor(maxChilds / 2);
    
    this.root = [];
}
BTree.prototype = {
    get length() {
        return this.root.count || 0;
    },
    
    get size() {
        return this.root.size || 0;
    },
    
    /**
     * Loads a data set efficiently into the tree
     */
    load : function(data){
        throw Error("not implemented");
    },
    
    /**
     * 
     */
    loadHumongousSet : function(count, size){
        this.defaultSize = size;
        this.root = [];
        this.root.size  = size * count;
        this.root.count = count;
    },
    
    /**
     * Add an object to the tree
     * @param afterIndex {Number} the index of the node to insert after. Null to append as last child.
     * @param size       {Number} the size of the node (usually stands for pixels)
     * @param value      {Mixed}  the value of the node
     */
    add : function(afterIndex, size, value){
        throw Error("not implemented");
    },
    
    checkParents : function(parent){
        throw Error("not implemented");
    },
    
    /**
     * Updates the size of nodes
     */
    updateNodes : function(nodes){
        var root = this.root;
        nodes.forEach(function(n) {
            root[n.index] = n;
        })
    },
    
    remove : function(index){
        
    },
    
    findSizeAtIndex : function(index){
        var root = this.root;
        var s = 0;  
        var defSize = this.defaultSize;
        index = Math.min(index, root.count);
        for (var i = 0; i < index; i++) {
            var el = root[i];
            s += el ? el.size : defSize;
        }
        return s;
    },
    
    /**
     * Returns an array of nodes that are within the viewport specified
     *  returned array contains additional properties
     *  size : offset from top (unlike property with the same name  on nodes)
     *  index : index
     *  if compIndex is true start and end are indexes otherwise offsets
     * @todo should return the start index of the first node as well
     */
    getRange : function(start, end, compIndex){
        var root = this.root;
        var nodes = [];  
        var defSize = this.defaultSize;
        var fsize = 0;
        var fcount = 0;
        if (!compIndex) {
            var s = 0;
            for(var i = 0; i < root.count; i++) {
                var el = root[i];
                s += el ? el.size : defSize;
                if (s > start) {
                    s -= el ? el.size : defSize;
                    break;
                }
            }
            var startIndex = i;
            fsize = s;
            for (var i = startIndex; fsize < end; i++) {
                if (i >= this.root.count)
                    break;
                var node = root[i] || {
                    size   : defSize,
                    empty  : true,
                    parent : root,
                    count  : 1,
                    index  : i
                }
                nodes.push(node);
                fcount++;
                fsize += node.size;
            }
            nodes.size  = s;
            nodes.count = startIndex;
            nodes.index = startIndex;
        } else {
            for (var i = start; i < end; i++) {
                var node = root[i]
                if (node)
                    node.index = i;
                else
                    node = {
                        size   : defSize,
                        empty  : true,
                        parent : root,
                        count  : 1,
                        index  : i
                    }
                nodes.push(node);
                fcount++;
                fsize += node.size;
            }
            nodes.size  = s;
            nodes.count = start;
            nodes.index = start;
        }
        
        return nodes;
    },
    
    /**
     * Returns the node at some arbitrary total position
     * @param offset {Number} the start position from where to find the node
     */
    findNodeAtStart : function(offset){
        var size = 0;
        
        var root = this.root;
        var s = 0;
        var defSize = this.defaultSize;
        for(var i = 0; i < root.count; i++) {
            var el = root[i];
            if (el) {
                s += el.size;
            } else {
                s += defSize
            }
            if (s > offset) {
                break
            }
        }
        if (el)
            el.index = i;
        else
            el = {
                size   : defSize,
                count  : 1,
                parent : this.root,
                index  : i
            };
        
        return el;
    },
    
    /**
     * Returns the node at some index
     * @param index {Number} the zero based index of the node, calculated sequentially.
     */
    findNodeByIndex : function(index){
        var defSize = this.defaultSize;
        return this.root[index] || {
            size   : defSize, 
            empty  : true, 
            count  : 1,
            parent : this.root,
            index  : index
        };
    },
    
    /**
     * Returns the last node in the tree, sequentially
     */
    findLastNode : function(){
        return (function recur(node){
            if (node.length) return recur(node[node.length - 1]);
            else return node;
        })(this.root);
    },
    
    /**
     * Returns the first node in the tree, sequentially
     */
    findFirstNode : function(){
        return (function recur(node){
            if (node.length) return recur(node[0]);
            else return node;
        })(this.root);
    },
    
    /**
     * Return an array of all objects in tree, sequentially.
     * Each object has a size and value property
     */
    toArray : function(){
        throw Error("not implemented");
    }
};

module.exports = BTree;

});