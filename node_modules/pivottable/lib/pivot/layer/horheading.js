define(function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var lang = require("../lib/lang");
var useragent = require("../lib/useragent");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var BTree = require("../lib/btree");

var HorHeading = function(parentEl, width, height) {
    this.element = dom.createElement("div");
    this.element.className = "pivot_heading pivot_horheading-layer";
    parentEl.appendChild(this.element);
    
    this.heightCache = "px;height:" + height + "px";
    
    this.visible    
    this.height      = height;
    this.minSize     = 25;
    this.defaultSize = width;
    BTree.call(this, 25);
};
oop.inherits(HorHeading, BTree);

(function() {
    oop.implement(this, EventEmitter);

    this.setDataProvider = function(provider) {
        this.provider = provider;
        
        // @todo col width measuring could be done here
        
        if (provider.columns !== undefined) {
            var def = this.defaultSize
            var size = provider.columns <= 3 ? 2 * def : def;
            this.loadHumongousSet(provider.columns, size);
            this.defaultSize = def;
        }
    };
    
    this.toggle = function(heading, callback) {
        console.log("Toggling is not supported");
        return callback && callback();
        
        if (!this.provider.totals)
            return;
        
        var index = heading.index;
        if (index === 0) return false;
        
        // var name     = heading.name;
        var provider = this.provider;
        var x        = provider.x;
        var start    = heading.start;
        var total    = 1, i, l;
        
        for (i = 0; i < index; i++) {
            total *= provider.entities[x[i]].length + (i < index - 1 ? 1 : 0);
        }
        
        if (start && (start - total) % (total + 1) === 0)
            start -= total;
        
        var r, range = this.getRange(start, start + total + 1, true);
        if (range[1].oldsize && range[1].oldsize[index - 1] !== undefined) {
            for (i = 0, l = range.length - 1; i < l; i++) {
                r = range[i];
                var newsize = r.oldsize.pop(); 
                if (newsize !== undefined)
                    r.size = newsize;
            }
        }
        else {
            for (i = 0, l = range.length - 1; i < l; i++) {
                r = range[i];
                if (!r.oldsize) r.oldsize = [];
                r.oldsize[index - 1] = r.size;
                r.size = 0;
            }
        }
        
        range.pop(); //Remove totals column;
        
        this.updateNodes(range);
        
        return true;
    };
    
    this.setAlignment = function(index, type){
        var node = this.findNodeByIndex(index);
        if ("top|middle|bottom".indexOf(type) > -1) {
            node.valign = "valign-" + type;
        }
        else {
            node.align = "align-" + type;
        }
        
        this.updateNodes([node]);
    }
    
    this.update = function(config) {
        this.element.style.height = this.visible ? "" : "0px";
        this.element.style.overflow = this.visible ? "" : "hidden";
        
        if (this.provider.headingRange)
            this.updateRange(config);
        else
            this.updateOwn(config);
    };
    
    this.updateRange = function(config){
        var start    = config.firstCol;
        var length   = config.lastCol - config.firstCol + 1;
        var provider = this.provider;
        var _self    = this;
        
        var curHeight = this.element.offsetHeight; //@todo this should be cached
        
        provider.getHeadingRange(start, length, false, function(err, columns){
            if (err) return;
            
            // Process heading info
            var html = [], isMin = [];
            var range = config.hRange;
            
            var hTotals = config.hTotals = {};
            
            // loop over all columns
            for (var j = 0; j < columns.length; j++) {
                // for each column add a heading for each level
                var builder = html[j] || (html[j] = []);
                var col = columns[j];
                var cellSize = range[0] && range[0].size || 0;
                var rowName = col[0];
                var last = {count: 0, name: rowName};
                
                for (var i = 1, l = col.length; i <= l; i++) {
                    if (i != l) {
                        rowName = col[i];
                        
                        // If it's not the end of the last cell, continue
                        if (rowName == last.name && !/^!!AGGREGATE/.test(last.name)) {
                            cellSize += range[i] && range[i].size || 0;
                            last.name = rowName;
                            last.count++;
                            continue;
                        }
                    }
                    
                    // Let's draw this cell
                    var lastName = last.name;
                    
                    last.name = rowName;
                    last.count = 0;
                    
                    if (lastName && /^!!AGGREGATE!!/.test(lastName)) {
                        hTotals[i - 1] = j + 1; // Why not true?
                        lastName = lastName.replace(/^!!AGGREGATE!!(.+)/, "$1");
                    }

                    
                    var isTotal      = hTotals[i - 1] == j + 1;
                    var isOtherTotal = hTotals[i - 1] && hTotals[i - 1] > j + 2 ? true : false;
                    
                    if (isOtherTotal) {
                        builder.push("<span style='width: " + range[j].size 
                            + "px' class='total sub'>&nbsp;</span>");
                    }
                    else {
                        var width = cellSize;
                        if (width !== 0) {
                            builder.push("<span style='width:" + width
                                + _self.heightCache + "' "
                                + (isTotal ? "class='total'" : '') 
                                + ">" 
                                + (col.first
                                  ? (j < columns.length - 1 && provider.totals[provider.x[j]] && lastName != "Total"
                                      ? "<span " + (isMin[j - 1] ? "class='plus'" : "") + "></span>" 
                                      : "") 
                                    + (j == columns.length - 1
                                        ? "<u class='icon-chevron-sign-down menu'></u>" 
                                        : "") 
                                    + (lastName || "&nbsp;")
                                  : "&nbsp;") + "</span>");
                            isMin[j - 1] = false;
                        }
                        else isMin[j] = true;
                    }
                    
                    cellSize = range[i] && range[i].size || 0;
                }
            }
            
            for (j = 0; j < columns.length; j++) {
                html[j] = html[j].join("");
            }
            
            _self.element = dom.setInnerHtml(_self.element, 
                "<div>" + html.join("</div><div>") + "</div>");
            
            if (_self.element.offsetHeight != curHeight)
                _self._emit("changeHeight");
        });
    };
    
    this.updateOwn = function(config){ 
        this.config = config;

        clearTimeout(this.timer);

        var headings  = this;
        var provider  = this.provider;
        var curHeight = this.element.offsetHeight; //@todo this should be cached
        
        var x = provider.x;
        
        var totals = false;
        for (var name in provider.totals) { 
            if (x.indexOf(name) > -1) 
                totals = true; 
            break; 
        }
        
        var start = config.firstCol, length = config.lastCol - config.firstCol + 1;
        var o, i, l, fields = [], name, lastlength, lasttotal;
        
        // Get column count for each heading
        var hTotals = config.hTotals = {};
            
        function update(err, data, hasNew){
            if (hasNew) {
                headings.timer = setTimeout(function(){ 
                    headings.update(config); 
                }, 100);
            }
        }
        
        // Fetch names for each level of columns
        for (i = 0, l = x.length; i < l; i++) {
            name = x[i];
            o = {
                name : name,
                compound : i === 0 ? 1 : ((fields[i - 1].compound
                    * provider.entities[x[i - 1]].length)
                    + (provider.totals[fields[i - 1].name] ? 1 : 0))
            }
            o.total      = provider.entities[x[i]].length + (provider.totals[name] ? 1 : 0);
            o.length     = Math.ceil((lastlength || length) / (lasttotal || 1)) + 1;
            fields.push(o);
            
            lastlength = o.length;
            lasttotal  = o.total;
        }
        
        for (i = x.length - 1; i >= 0; i--) {
            name = x[i];
            o = fields[i];
            
            o.counter    = 0;
            o.cell       = start;
            o.start      = Math.floor(start / o.compound);
            o.normalized = (o.length + (provider.totals[name] ? 1 : 0)) >= o.total;
            o.list       = o.normalized
                ? provider.getEntityRange(name, 0, null, update)
                : provider.getEntityRange(name, o.start % o.total, o.length, update);
            
            start = start % o.compound;
        }
        
        // @todo it might be better to render in this recur loop
        if (totals) {
            var i      = x.length - 1;
            var start  = config.firstCol % fields[x.length - 1].compound;
            var offset = config.firstCol - start;
            var end    = config.lastCol - offset;
            
            // Start with outer heading
            (function recur(i, start, end, offset){
                var row       = fields[i];
                var total     = row.compound;
                var showTotal = provider.totals[fields[i - 1].name] ? 1 : 0;
                
                var d = start % total, f = total - d - 1;
                
                // Find all occurences in this window
                var count = Math.ceil((end - start + d) / total);
                // if (count < 1) count = 1;
                
                if (showTotal && f <= end - start)
                    hTotals[f + offset] = i;
                
                // for each occurance, define a sub window
                for (var j = 0; j < count; j++) {
                    if (showTotal && j > 0)
                        hTotals[f + offset + (j * total)] = i;
                    
                    // Recur
                    if (i > 1) {
                        recur(i - 1, 
                            j ? 0 : start, 
                            Math.min(end, total - 1), //Math.min(end, start - d + ((j + 1) * total) - 1),
                            offset - (j ? d : 0) + (j * total));
                    }
                }
            })(i, start, end, 0)
        }
        
        var j, html = [], row, total = 0, isMin = [];
        var range = config.hRange, index, lookup, builder, final;
        
        // loop over all columns
        for (j = 0; j < length + 1; j++) {
            final = j == length;
            !final && (total += range[j].size);
            
            // for each column add a heading for each level
            for (i = 0, l = fields.length; i < l; i++) {
                row    = fields[i];
                index  = (row.start + row.counter) % row.total;
                lookup = row.normalized ? index : row.counter;
                row.counter++
                
                builder = html[i] || (html[i] = []);
                
                if (final && (i === 0 || total - (row.last || 0) === 0)) {
                    html[i] = builder.join("");
                    continue;
                }
                
                if (totals) {
                    var isTotal      = hTotals[j] == i + 1;
                    var isOtherTotal = hTotals[j] && hTotals[j] > i + 1 ? true : false
                    
                    if (isOtherTotal) {
                        builder.push("<span style='width: " + range[j].size 
                            + "px' class='total sub'>&nbsp;</span>");
                        row.start = row.start % fields[hTotals[j]].compound - 1;
                        if (!final)
                            continue;
                    }
                    else if (i === 0) {
                        if (range[j].size !== 0)
                            builder.push("<span style='width: " + range[j].size 
                                + this.heightCache + "' "
                                + (isTotal ? "class='total'" : '') 
                                + ">" 
                                + (row.list[lookup] || "&nbsp;") + "</span>")
                        else isMin[i] = true;
                    }
                    else {
                        var width = (total - (row.last || 0));
                        if (width !== 0) {
                            builder.push("<span style='width:" + width
                                + this.heightCache + "' "
                                + (isTotal ? "class='total'" : '') 
                                + ">" 
                                + (builder.length || (row.cell % row.compound) < 1
                                  ? (isTotal 
                                    ? "" 
                                    : "<span " + (isMin[i - 1] ? "class='plus'" : "") + "></span>") 
                                      + (row.list[lookup] || "&nbsp;")
                                  : "&nbsp;") + "</span>");
                            isMin[i - 1] = false;
                        }
                        else isMin[i] = true;
                        row.last = total;
                    }
                }
                else {
                    if (i === 0) {
                        if (range[j].size !== 0)
                            builder.push("<span style='width: " + range[j].size 
                                + this.heightCache + "'>" 
                                + (row.list[lookup] || "&nbsp;") + "</span>")
                        else isMin[i] = true;
                    }
                    else {
                        var width = (total - (row.last || 0));
                        builder.push("<span style='width:" + width 
                            + this.heightCache + "'>" 
                            + (builder.length || (row.cell % row.compound) < 1
                                ? (row.list[lookup] || "&nbsp;") 
                                : "&nbsp;") + "</span>");
                        row.last = total;
                    }
                }
                
                if (final)
                    html[i] = builder.join("");
                else if (index !== row.total - 1) // || row.counter === 1
                    break;
            }
        }
        
        this.element = dom.setInnerHtml(this.element, 
            "<div>" + html.reverse().join("</div><div>") + "</div>");
        
        if (this.element.offsetHeight != curHeight)
            this._emit("changeHeight");
    };
    
    this.scroll = function(config) {
        // var oldConfig = this.config;
        // this.config = config;
        // 
        // if (oldConfig.firstRow == config.firstRow
        //   && oldConfig.firstCol == config.firstCol)
        //     return;
        // 
        // // @todo partial horizontal updating
        // var datarow, el = this.element, view = config.view, length;
        // if (oldConfig) {
        //     var diff      = config.firstRow - oldConfig.firstRow;
        //     var threshold = Math.ceil(config.lastRow - config.firstRow * 2 / 3);
        //     var i, j, row, html = [];
        //     
        //     if (diff < 0) {
        //         if (diff > -1 * threshold) {
        //             for (row, i = -1; i > diff - 1; i--) {
        //                 row     = el.lastChild; 
        //                 length  = config.lastCol - config.firstCol;
        //                 datarow = view[oldConfig.firstRow + i];
        //                 
        //                 el.insertBefore(row, el.firstChild);
        //                 
        //                 for (j = 0; j < length; j++) {
        //                     html.push("<span>" + datarow[j] + "</span>");
        //                 }
        //                 
        //                 dom.setInnerHtml(row, html.join(""));
        //             }
        //             return;
        //         }
        //     }
        //     else if (diff < threshold) {
        //         for (row, i = 0; i < diff; i++) {
        //             row     = el.firstChild;
        //             length  = config.lastCol - config.firstCol;
        //             datarow = view[length - diff + i];
        //             
        //             el.appendChild(row);
        //             
        //             for (j = 0; j < length; j++) {
        //                 html.push("<span>" + datarow[j] + "</span>");
        //             }
        //             
        //             dom.setInnerHtml(row, html.join(""));
        //         }
        //         return;
        //     }
        // }
        // 
        this.update(config);
    };
    
    this.updateRows = function(config, firstRow, lastRow) {
//         this.config = config;
// 
//         var col, row, html = [], view = config.view, datarow;
//         var firstCol = config.firstCol, lastCol = config.lastCol;
//         var i = config.firstRow - firstRow;
//         var l = lastRow - config.firstRow;
// 
//         var el = this.element;
//         for (i = 0; i < l; i++) {
//             row = el.childNodes[i];
//             
//             datarow = view[i];
//             html    = [];
//             for (col = firstCol; col <= lastCol; col++) {
//                 html.push("<span>" + datarow[col - firstCol] + "</span>");
//             }
//             
//             dom.setInnerHtml(row, html.join(""));
//         }
        
        this.update(config);
    };

    this.destroy = function() {
        
    };

}).call(HorHeading.prototype);

exports.HorHeading = HorHeading;

});
