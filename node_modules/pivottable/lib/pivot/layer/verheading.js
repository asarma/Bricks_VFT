define(function(require, exports, module) {
"use strict";

var oop = require("../lib/oop");
var dom = require("../lib/dom");
var EventEmitter = require("../lib/event_emitter").EventEmitter;
var BTree = require("../lib/btree");

var VerHeading = function(parentEl, width, height) {
    this.element = dom.createElement("div");
    this.element.className = "pivot_heading pivot_verheading-layer";
    parentEl.appendChild(this.element);
    
    this.widthCache = "px;width:" + width + "px";
    
    this.visible     = true;
    this.width       = width;
    this.minSize     = 25;
    this.defaultSize = height;
    BTree.call(this, 25);
    this.reset = this.reset.bind(this);
};
oop.inherits(VerHeading, BTree);

(function() {
    oop.implement(this, EventEmitter);
    
    this.reset = function() {
        if (this.provider.rows !== undefined)
            this.loadHumongousSet(this.provider.rows, this.defaultSize);
    };
    
    this.setDataProvider = function(provider) {
        if (this.provider && this.provider.off)
            this.provider.off("updateModel", this.reset);
        this.provider = provider;
        if (this.provider && this.provider.on)
            this.provider.on("updateModel", this.reset);
        this.reset();
        // @todo col width measuring could be done here
    };
    
    this.toggle = function(heading, callback) {
        if (this.provider.headingRange)
            return this.toggleRange(heading, callback);
        else
            return this.toggleOwn(heading, callback);
    };
    
    this.toggleRange = function(heading, callback){
        var start = heading.start;
        var index = heading.index;
        
        var _self    = this;
        var provider = this.provider;
        
        var column = provider.$headings.y[index];
        
        var name = column[start];
        for (var endIndex = start + 1; endIndex < column.length; endIndex++) {
            if (column[endIndex] != name)
                break;
        }
        for (start -= 1; start >= 0; start--) {
            if (column[start] != name)
                break;
        }
        start++;
        if (start === endIndex - 1)
            return callback(false);
        var range = _self.getRange(start, endIndex, true);
        var r, i, l;
        
        // todo: rewrite btree
        if (range.length != endIndex - start)
            range.length = endIndex - start;

        if (range[0].collapsed && range[0].collapsed[index]) {
            range[0].collapsed[index] = false;
            for (i = 1, l = range.length; i < l; i++) {
                r = range[i];
                var newsize = r.oldsize && r.oldsize[index];
                if (newsize !== undefined) {
                    r.oldsize[index] = undefined;
                    for (var k = index; k--;) {
                        if (r.oldsize[k] === 0) {
                            r.oldsize[k] = newsize;
                            break;
                        }
                    }
                    if (k < 0)
                        r.size = newsize;
                }
            }
        }
        else {
            if (!range[0].collapsed) 
                range[0].collapsed = [];
            range[0].collapsed[index] = true;
            for (i = 1, l = range.length; i < l; i++) {
                r = range[i];
                if (!r.oldsize) r.oldsize = [];
                if (r.size || !r.oldsize[index])
                    r.oldsize[index] = r.size;
                r.size = 0;
            }
        }

        _self.updateNodes(range);
                
        callback(true);        
    };
    
    this.toggleOwn = function(heading, callback){
        if (!this.provider.totals)
            return callback(false);
        
        var index = heading.index;
        if (index === 0) return false;
        
        // var name     = heading.name;
        var provider = this.provider;
        var y        = provider.y;
        var start    = heading.start;
        var total    = 1, i, l;
        
        for (i = 0; i < index; i++) {
            total *= provider.entities[y[i]].length + (i < index - 1 ? 1 : 0);
        }
        
        if (start && (start - total) % (total + 1) === 0)
            start -= total;
        
        var r, range = this.getRange(start, start + total + 1, true);
        if (range[1].oldsize && range[1].oldsize[index - 1] !== undefined) {
            for (i = 0, l = range.length - 1; i < l; i++) {
                r = range[i];
                var newsize = r.oldsize.pop(); 
                if (newsize !== undefined)
                    r.size = newsize;
            }
        }
        else {
            for (i = 0, l = range.length - 1; i < l; i++) {
                r = range[i];
                if (!r.oldsize) r.oldsize = [];
                r.oldsize[index - 1] = r.size;
                r.size = 0;
            }
        }
        
        range.pop(); //Remove totals column;
        
        this.updateNodes(range);
        
        callback(true);
    };
    
    this.setAlignment = function(index, type){
        var node = this.findNodeByIndex(index);
        if ("top|middle|bottom".indexOf(type) > -1) {
            node.valign = "valign-" + type;
        }
        else {
            node.align = "align-" + type;
        }
        
        this.updateNodes([node]);
    };
    
    this.update = function(config) {
        this.element.style.width = this.visible ? "" : "0px";
        this.element.style.overflow = this.visible ? "" : "hidden";
        
        if (this.provider.headingRange)
            this.updateRange(config);
        else
            this.updateOwn(config);
    };
    
    this.updateRange = function(config){
        var start    = config.firstRow;
        var length   = config.lastRow - config.firstRow + 1;
        var provider = this.provider;
        var _self    = this;
        
        var curWidth = this.element.offsetWidth; //@todo this should be cached
        
        provider.getHeadingRange(start, length, true, function(err, columns){
            if (err) return;
            
            // Process heading info
            var html = [], isMin = [];
            var range = config.vRange;
            
            var hRange = _self.getHeadingRange();
            
            var vTotals = config.vTotals = {};
            
            var tree = provider.$headingTree && provider.$headingTree.y;
            var togglers = [];
            function getTogglerState(i, j, rowName, rowLength) {
                if (!tree || rowLength < 1) return "";
                if (j === 0) {
                    var parent = tree;
                } else {
                    for (var k = i + 1 - rowLength; k >= 0; k--) {
                        parent = togglers[k];
                        if (parent) 
                            break;
                    }
                }
                if (!parent) return "";
                var node = parent["_" + rowName];
                togglers[i + 1 - rowLength] = node || {};
                if (!togglers[i + 1])
                    togglers[i + 1] = parent;
                
                if (!node || node.count <= 1)
                    return "";
                
                return node.collapsed ? "plus" : "minus";
            }
            
            // loop over all columns
            for (var j = 0; j < columns.length; j++) {
                // for each column add a heading for each level
                var builder = html[j] || (html[j] = []);
                var col = columns[j];
                var cellSize = range[0] && range[0].size || 0;
                var rowName = col[0];
                var last = {count: 0, name: rowName};
                
                for (var i = 1, l = col.length; i <= l; i++) {
                    if (i != l) {
                        rowName = col[i];
                        
                        // If it's not the end of the last cell, continue
                        if (rowName == last.name && !/^!!AGGREGATE/.test(last.name)) {
                            cellSize += range[i] && range[i].size || 0;
                            last.name = rowName;
                            last.count++;
                            continue;
                        }
                    }
                    
                    // Let's draw this cell
                    var lastName = last.name;
                    var lastCount = last.count;
                    last.name = rowName;
                    last.count = 0;
                    
                    if (lastName && /^!!AGGREGATE!!/.test(lastName)) {
                        vTotals[i - 1] = j + 1; // Why not true?
                        lastName = lastName.replace(/^!!AGGREGATE!!(.+)/, "$1");
                    }
                    
                    var isTotal      = vTotals[i - 1] == j + 1;
                    var isOtherTotal = vTotals[i - 1] && vTotals[i - 1] > j + 2 ? true : false;
                    
                    if (isOtherTotal) {
                        builder.push("<span style='height: " + range[j].size 
                            + "px' class='total sub'>&nbsp;</span>");
                    }
                    else {
                        var height = cellSize;
                        if (height !== 0) {
                            
                            var toggler = getTogglerState(i, j, lastName, lastCount);
                            if (toggler) {
                                var node = range[i - lastCount - 1];
                                if (node && node.collapsed && node.collapsed[j])
                                    toggler = "plus";
                            }
                            builder.push(
                                "<span style='height:" + height
                                + "px;width:" + hRange[j] + "px" + "' "
                                + (isTotal ? "class='total'" : '') 
                                + ">" 
                                + (col.first
                                  ? (j < columns.length - 1 && toggler
                                      ? "<span class='toggler " + toggler + "'></span>" 
                                      : "") 
                                    + (j == columns.length - 1
                                        ? "<u class='icon-chevron-sign-down menu'></u>" 
                                        : "") 
                                    + (lastName || "&nbsp;")
                                  : "&nbsp;")
                                + "</span>"
                            );
                            isMin[j - 1] = false;
                        }
                        else isMin[j] = true;
                    }
                    
                    cellSize = range[i] && range[i].size || 0;
                }
            }
            
            for (j = 0; j < columns.length; j++) {
                html[j] = html[j].join("");
            }
            
            _self.element = dom.setInnerHtml(_self.element, 
                "<div>" + html.join("</div><div>") + "</div>");
            
            if (_self.element.offsetWidth != curWidth)
                _self._emit("changeWidth");
        });
    };
    
    this.getHeadingRange = function(columns) {
        if (!this.headingRange)
            this.headingRange = [];
        
        
        var l = this.provider.y.length;
        if (this.headingRange.length < l) {
            for (var i = 0; i < l; i++) {
                if (this.headingRange[i] == undefined) 
                    this.headingRange[i] = this.width;
            }
        }
        return this.headingRange;
    };
    
    this.updateOwn = function(config) {
        this.config = config;

        clearTimeout(this.timer);

        var headings  = this;
        var provider  = this.provider;
        var curWidth = this.element.offsetWidth; //@todo this should be cached
        
        var y = provider.y;
        
        var totals = false;
        for (var name in provider.totals) { 
            if (y.indexOf(name) > -1) 
                totals = true; 
            break; 
        }
        
        var start = config.firstRow, length = config.lastRow - config.firstRow + 1;
        var o, i, l, fields = [], lastlength, lasttotal;
        
        // Get column count for each heading
        var vTotals = config.vTotals = {};
            
        function update(err, data, hasNew){
            if (hasNew) {
                headings.timer = setTimeout(function(){ 
                    headings.update(config); 
                }, 100);
            }
        }
        
        // Fetch names for each level of columns
        for (i = 0, l = y.length; i < l; i++) {
            name = y[i];
            o = {
                name : name,
                compound : i === 0 ? 1 : ((fields[i - 1].compound
                    * provider.entities[y[i - 1]].length) 
                    + (provider.totals[fields[i - 1].name] ? 1 : 0))
            }
            o.total      = provider.entities[y[i]].length + (provider.totals[name] ? 1 : 0);
            o.length     = Math.ceil((lastlength || length) / (lasttotal || 1)) + 1;
            fields.push(o);
            
            lastlength = o.length;
            lasttotal  = o.total;
        }
        
        for (i = y.length - 1; i >= 0; i--) {
            name = y[i];
            o = fields[i];
            
            o.counter    = 0;
            o.cell       = start;
            o.start      = Math.floor(start / o.compound);
            o.normalized = (o.length + (provider.totals[name] ? 1 : 0)) >= o.total;
            o.list       = o.normalized
                ? provider.getEntityRange(name, 0, null, update)
                : provider.getEntityRange(name, o.start % o.total, o.length, update);
            
            start = start % o.compound;
        }
        
        // @todo it might be better to render in this recur loop
        if (totals) {
            var i      = y.length - 1;
            var start  = config.firstRow % fields[y.length - 1].compound;
            var offset = config.firstRow - start;
            var end    = config.lastRow - offset;
            
            // Start with outer heading
            (function recur(i, start, end, offset){
                var row       = fields[i];
                var total     = row.compound;
                var showTotal = provider.totals[fields[i - 1].name] ? 1 : 0;
                
                var d = start % total, f = total - d - 1;
                
                // Find all occurences in this window
                var count = Math.ceil((end - start + d) / total);
                // if (count < 1) count = 1;
                
                if (showTotal && f <= end - start)
                    vTotals[f + offset] = i;
                
                // for each occurance, define a sub window
                for (var j = 0; j < count; j++) {
                    if (showTotal && j > 0)
                        vTotals[f + offset + (j * total)] = i;
                    
                    // Recur
                    if (i > 1) {
                        recur(i - 1, 
                            j ? 0 : start, 
                            Math.min(end, total - 1), //Math.min(end, start - d + ((j + 1) * total) - 1),
                            offset - (j ? d : 0) + (j * total));
                    }
                }
            })(i, start, end, 0);
        }
        
        var j, html = [], row, total = 0, isMin = [];
        var range = config.vRange, index, lookup, builder, final;
        
        // loop over all columns
        for (j = 0; j < length + 1; j++) {
            final = j == length;
            !final && (total += range[j].size);
            
            // for each column add a heading for each level
            for (i = 0, l = fields.length; i < l; i++) {
                row    = fields[i];
                index  = (row.start + row.counter) % row.total;
                lookup = row.normalized ? index : row.counter;
                row.counter++;
                
                builder = html[i] || (html[i] = []);
                
                if (final && (i === 0 || total - (row.last || 0) === 0)) {
                    html[i] = builder.join("");
                    continue;
                }
                
                if (totals) {
                    var isTotal      = vTotals[j] == i + 1;
                    var isOtherTotal = vTotals[j] && vTotals[j] > i + 1 ? true : false;
                    
                    if (isOtherTotal) {
                        builder.push("<span style='height: " + range[j].size 
                            + "px' class='total sub'>&nbsp;</span>");
                        row.start = row.start % fields[vTotals[j]].compound - 1;
                        if (!final)
                            continue;
                    }
                    else if (i === 0) {
                        if (range[j].size !== 0)
                            builder.push("<span style='height: " + range[j].size 
                                + this.widthCache + "' "
                                + (isTotal ? "class='total'" : '') 
                                + ">" 
                                + (row.list[lookup] || "&nbsp;") + "</span>");
                        else isMin[i] = true;
                    }
                    else {
                        var width = (total - (row.last || 0));
                        if (width !== 0) {
                            builder.push("<span style='height:" + width 
                                + this.widthCache + "' "
                                + (isTotal ? "class='total'" : '') 
                                + ">" 
                                + (builder.length || (row.cell % row.compound) < 1
                                  ? (isTotal 
                                    ? "" 
                                    : "<span " + (isMin[i - 1] ? "class='plus'" : "") + "></span>") 
                                      + (row.list[lookup] || "&nbsp;")
                                  : "&nbsp;") + "</span>");
                            isMin[i - 1] = false;
                        }
                        else isMin[i] = true;
                        row.last = total;
                    }
                }
                else {
                    if (i === 0) {
                        if (range[j].size !== 0)
                            builder.push("<span style='height: " + range[j].size 
                                + this.widthCache + "'>" 
                                + (row.list[lookup] || "&nbsp;") + "</span>");
                        else isMin[i] = true;
                    }
                    else {
                        var height = (total - (row.last || 0));
                        builder.push("<span style='height:" + height 
                            + this.widthCache + "'>" 
                            + (builder.length || (row.cell % row.compound) < 1
                                ? (row.list[lookup] || "&nbsp;") 
                                : "&nbsp;") + "</span>");
                        row.last = total;
                    }
                }
                
                if (final)
                    html[i] = builder.join("");
                else if (index !== row.total - 1) // || row.counter === 1
                    break;
            }
        }
        
        this.element = dom.setInnerHtml(this.element, 
            "<div>" + html.reverse().join("</div><div>") + "</div>");
        
        if (this.element.offsetWidth != curWidth)
            this._emit("changeWidth");
    };
    
    /*this.update = function(config) {
        this.config = config;

        clearTimeout(this.timer);

        var headings  = this;
        var provider  = this.provider;
        var curWidth = this.element.offsetWidth;//@todo this should be cached
        
        var y = provider.y;
        
        var start = config.firstRow, length = config.lastRow - config.firstRow + 1;
        var o, i, l, fields = [], each = [1], name, lastlength, lasttotal;
        
        function update(err, data, hasNew){
            if (hasNew) {
                headings.timer = setTimeout(function(){ 
                    headings.update(config); 
                }, 100);
            }
        }
        
        // Fetch names for each level of columns
        for (i = 0, l = y.length; i < l; i++) {
            name = y[i];
            o = {
                start  : start, 
            }
            fields.push(o);
            
            o.counter    = 0;
            o.total      = provider.entities[name].length;
            o.length     = Math.ceil((lastlength || length) / (lasttotal || 1)) + 1;
            o.normalized = o.length >= o.total;
            o.list       = o.normalized
                ? provider.getEntityRange(name, 0, null, update)
                : provider.getEntityRange(name, o.start % o.total, o.length, update);
            
            start = Math.floor(start / o.total);
            lastlength = o.length;
            lasttotal  = o.total;
        }
        
        var j, html = [], row, total = 0;
        var range = config.vRange, index, lookup, builder, final;
        
        // loop over all rows
        for (j = 0; j < length + 1; j++) {
            final = j == length;
            !final && (total += range[j].size);
            
            // for each row add a heading for each level
            for (i = 0, l = fields.length; i < l; i++) {
                row    = fields[i];
                index  = (row.start + row.counter) % row.total;
                lookup = row.normalized ? index : row.counter;
                row.counter++
                
                builder = html[i] || (html[i] = []);
                
                if (final && (i === 0 || total - (row.last || 0) === 0)) {
                    html[i] = builder.join("");
                    continue;
                }
                
                if (i === 0) {
                    if (range[j].size !== 0)
                        builder.push("<span style='height: " + range[j].size + "px'>" 
                            + (row.list[lookup] || "&nbsp;") + "</span>")
                }
                else {
                    builder.push("<span style='height:" 
                        + (total - (row.last || 0)) + "px'>" 
                        + (builder.length || (fields[0].start % fields[0].total) === 0
                            ? "<span></span>" + (row.list[lookup] || "&nbsp;") 
                            : "&nbsp;") + "</span>");
                    row.last = total;
                }
                
                if (final)
                    html[i] = builder.join("");
                else if (index !== row.total - 1) // || row.counter === 1
                    break;
            }
        }
        
        this.element = dom.setInnerHtml(this.element, 
            "<div>" + html.reverse().join("</div><div>") + "</div>");
        
        if (this.element.offsetWidth != curWidth)
            this._emit("changeWidth");
    };*/
    
    this.scroll = function(config) {
        // var oldConfig = this.config;
        // this.config = config;
        // 
        // if (oldConfig.firstRow == config.firstRow
        //   && oldConfig.firstRow == config.firstRow)
        //     return;
        // 
        // // @todo partial horizontal updating
        // var datarow, el = this.element, view = config.view, length;
        // if (oldConfig) {
        //     var diff      = config.firstRow - oldConfig.firstRow;
        //     var threshold = Math.ceil(config.lastRow - config.firstRow * 2 / 3);
        //     var i, j, row, html = [];
        //     
        //     if (diff < 0) {
        //         if (diff > -1 * threshold) {
        //             for (row, i = -1; i > diff - 1; i--) {
        //                 row     = el.lastChild; 
        //                 length  = config.lastRow - config.firstRow;
        //                 datarow = view[oldConfig.firstRow + i];
        //                 
        //                 el.insertBefore(row, el.firstChild);
        //                 
        //                 for (j = 0; j < length; j++) {
        //                     html.push("<span>" + datarow[j] + "</span>");
        //                 }
        //                 
        //                 dom.setInnerHtml(row, html.join(""));
        //             }
        //             return;
        //         }
        //     }
        //     else if (diff < threshold) {
        //         for (row, i = 0; i < diff; i++) {
        //             row     = el.firstChild;
        //             length  = config.lastRow - config.firstRow;
        //             datarow = view[length - diff + i];
        //             
        //             el.appendChild(row);
        //             
        //             for (j = 0; j < length; j++) {
        //                 html.push("<span>" + datarow[j] + "</span>");
        //             }
        //             
        //             dom.setInnerHtml(row, html.join(""));
        //         }
        //         return;
        //     }
        // }
        // 
        this.update(config);
    };
    
    this.updateRows = function(config, firstRow, lastRow) {
        // this.config = config;

        // var col, row, html = [], view = config.view, datarow;
        // var firstRow = config.firstRow, lastRow = config.lastRow;
        // var i = config.firstRow - firstRow;
        // var l = lastRow - config.firstRow;

        // var el = this.element;
        // for (i = 0; i < l; i++) {
        //     row = el.childNodes[i];
            
        //     datarow = view[i];
        //     html    = [];
        //     for (col = firstRow; col <= lastRow; col++) {
        //         html.push("<span>" + datarow[col - firstRow] + "</span>");
        //     }
            
        //     dom.setInnerHtml(row, html.join(""));
        // }
        
        this.update(config);
    };

    this.destroy = function() {
        
    };

}).call(VerHeading.prototype);

exports.VerHeading = VerHeading;

});
