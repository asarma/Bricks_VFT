define(function(require, exports, module) {
"use strict";
var dom = require("../lib/dom");
var event = require("../lib/event");

function VerticalHandler(mouseHandler) {
    var editor   = mouseHandler.editor;
    var layer    = editor.renderer.$verHeadingLayer;
    var htmlNode = editor.renderer.$verheading;
    
    var mouseState; // needed to make sure action on mousedown is same as shown by cursor
    var THRESHOLD = 3;
    var dragNode, dragIndex, dragDiff, dragY, dragX, dragSize, dragging, lastHover;
    
    function setDragInfoY(e){
        var config = editor.renderer.layerConfig;
        var range  = config.vRange;
        var rect   = editor.renderer.$verheading.getBoundingClientRect();
        
        var rY = e.y - rect.top;
        var rX = e.x - rect.left;
        
        var hrange = layer.getHeadingRange();
        var w = 0;
        for (var i = 0; i < hrange.length - 2; i++) {
            w += hrange[i];
        }
        // Resizing is only enabled for lowest headings
        if (rX > w) {
            // Lets find offset to clicked cell
            var total = 0, i = 0;
            while (total < rY) {
                if (!range[i]) return false;
                total += range[i++].size;
            }
            var size = range[i-1] && range[i-1].size;
            var diff = rY - total + size;
            
            // Size left border
            if (diff < THRESHOLD) {
                dragNode = range[i - 2];
                if (!dragNode) return; //Cannot size first heading
                
            }
            // Size right border
            else if (size - diff < THRESHOLD) {
                diff = diff - size;
                dragNode = range[i - 1];
            }
            // No sizing
            else return false;
            
            dragDiff = diff;
            dragY    = e.y;
            dragSize = size;
            
            var i = dragNode && dragNode.index;
            var y = layer.provider.$headings.y
            var lastCol = y[y.length - 1];
            
            return y.length < hrange.length || lastCol[i] != lastCol[i + 1];
        }
        
        return false;
    }
    
    function setDragInfoX(e){
        // var config = editor.renderer.layerConfig;
        var range = layer.getHeadingRange();
        
        var rect = editor.renderer.$verheading.getBoundingClientRect();
        
        var rY = e.y - rect.top;
        var rX = e.x - rect.left;
        
        // Resizing is only enabled for lowest headings
        // if (rY > (layer.provider.x.length - 1) * layer.height) {
            // Lets find offset to clicked cell
            var total = 0, i = 0;
            while (total < rX) {
                if (!range[i]) return false;
                total += range[i++];
            }
            var size = range[i - 1];
            var diff = rX - total + size;
            
            // Size left border
            if (diff < THRESHOLD) {
                dragIndex = i - 2;
                if (!range[dragIndex]) return; //Cannot size first heading
                
            }
            // Size right border
            else if (size - diff < THRESHOLD) {
                diff = diff - size;
                dragIndex = i - 1;
            }
            // No sizing
            else return false;
            
            dragDiff = diff;
            dragX    = e.x;
            dragSize = size;
            
            return true;
        // }
        
        return false;
    }
    
    function getHeadingCell(e){
        var config = editor.renderer.layerConfig;
        var range  = config.vRange;
        var rect   = editor.renderer.$verheading.getBoundingClientRect();
        var hrange = layer.getHeadingRange();
        
        var rY = e.y - rect.top;
        var rX = e.x - rect.left;

        var node = layer.findNodeAtStart(rY);
        if (!node)
            return;
        var index = -1, x = 0;
        do {
            index++;
            x += hrange[index];
        } while (rX > x && index < hrange.length);

        return {
            index : index,
            start : node.index
        }
    }
    
    mouseHandler.editor.setDefaultHandler("verticalclick", function(e) {
        // Detect menu click
        if (e.domEvent.target.className.indexOf(" menu") > -1) {
            e.vertical = true;
            e.index    = getHeadingCell(e).start;
            editor._emit("menu", e);
        }
    });
    
    mouseHandler.editor.setDefaultHandler("verticalmousedown", function(e) {
        e.preventDefault();
        var state = mouseState || updateMouseState(e)
        if (state) {
            mouseHandler.setState(state);
            mouseHandler.captureMouse(e);
            dragging = true;
            return;
        }
        
        var heading = getHeadingCell(e);
        if (dom.hasCssClass(e.domEvent.target, "toggler")) {
            layer.toggle(heading, function(succes){
                if (succes) {
                    editor.renderer.updateVerticalHeadings();
                    editor.renderer.updateCells();
                    editor.renderer.updateCaret();
                }
            })
        }
    });
    
    function updateMouseState(e) {
        var state = setDragInfoY(e) 
            ? "resizeVertical" : (setDragInfoX(e) ? "resizeVHorizontal" : "");
        htmlNode.style.cursor = state == "resizeVertical" 
            ? "ns-resize" : state == "resizeVHorizontal" ? "ew-resize" : "";
         
        return mouseState = state;
    }
    
    mouseHandler.editor.setDefaultHandler("verticaldblclick", function(e) {        
        var heading = getHeadingCell(e);
        var explore = layer.provider.explore && layer.provider.explore(heading, true);
        if (explore)
            return;
        layer.toggle(heading, function(succes){
            if (succes) {
                editor.renderer.updateVerticalHeadings();
                editor.renderer.updateCells();
                editor.renderer.updateCaret();
            }
        });
        e.preventDefault();
    });

    mouseHandler.editor.setDefaultHandler("verticalmousemove", function(e) {
        if (!dragging) {
            updateMouseState(e);
            return;
        }
        
        mouseHandler[mouseHandler.state](e);
    });
    
    mouseHandler.resizeVertical = function(e){
        dragNode.size = Math.max(layer.minSize, dragSize + ((e || this).y - dragY));
        layer.updateNodes([dragNode]);
        editor.renderer.updateVerticalHeadings();
        editor.renderer.updateCells();
        editor.renderer.updateCaret();
    }
    
    mouseHandler.resizeVHorizontal = function(e){
        layer.headingRange[dragIndex] =
            Math.max(layer.minSize, dragSize + ((e || this).x - dragX))
        editor.renderer.updateVerticalHeadings();
        editor.renderer.updateCells();
        editor.renderer.updateCaret();
    }

    event.addListener(htmlNode, "mouseup", function(e) {
        if (!dragging) return;
        
        mouseHandler.resizeVerticalEnd();
    });
    
    mouseHandler.resizeVHorizontalEnd =
    mouseHandler.resizeVerticalEnd   = function(){
        dragging = false;
        htmlNode.style.cursor = "";
    }
    
    event.addListener(htmlNode, "mouseout", function(e) {
    });

}

exports.VerticalHandler = VerticalHandler;

});
