if (typeof module !== "undefined") {
    require("amd-loader");
}

define(function(require, exports, module) {

var emitter = require("pivot/lib/event_emitter").EventEmitter;

function DataProvider(){
    var e = emitter; //@todo this should be an object instantiation
    
    this.on   = e.on.bind(e);
    this.once = e.once.bind(e);
    this.off  = e.off.bind(e);
    this.emit = e._emit.bind(e);
    
    this.ready = false;
}
DataProvider.prototype = {
    load : function(entities, latency, generateEntity, generateData){
        entities.forEach(function(item){
            entities[item.name] = item;
        });
        
        this.entities       = entities;
        this.latency        = latency;
        this.generateEntity = generateEntity;
        this.generateData   = generateData;
        
        this.entityCache = {};

        this.ready = true;
        this.emit("ready");
    },
    
    /**
     * 
     */
    getEntityRange : function(name, start, length, callback){
        var data   = this.entityCache[name] || (this.entityCache[name] = [])
        var cache  = data.slice(start, length ? start + length : undefined);
        var ln = this.entities[name].length;
        
        var generate = this.generateEntity;
        if (this.latency)
            setTimeout(function(){
                var updated = false;
                for (var i = start; i < start + length; i++) {
                    if (!cache[i - start]) {
                        updated = true;
                        cache[i - start] = data[i] = generate(name, i % ln);
                    }
                }

                callback(null, cache, updated);
            }, this.latency);
        else
            callback(null, cache, false);
        
        return cache;
    },
    
    /**
     * 
     */
    setQuery : function(x, y, aggregate, totals, callback){
        if (x) this.x = x;
        if (y) this.y = y;
        
        this.totals = totals ? 1 : 0;

        var entities = this.entities;
        var rows = 1;
        y.forEach(function(name){ rows *= entities[name].length });
        var columns = 1;
        x.forEach(function(name){ columns *= entities[name].length });

        this.rows    = rows;
        this.columns = columns;
        
        this.dataCache = new bigArray(rows);
        
        if (this.latency)
            setTimeout(callback, this.latency);
        else
            callback();
    },
    
    /**
     * 
     */
    getDataRange : function(rows, columns, callback){
        var generate = this.generateData;
        var cache    = this.dataCache;

        var view = cache.slice(rows.start, rows.start + rows.length);
        for (var i = 0; i < view.length; i++) {
            if (view[i])
                view[i] = view[i].slice(columns.start, columns.start + columns.length);
        }
        
        var columnLength = this.columns;
        function cb(){
            var updated = false;
            for (var i = rows.start; i < rows.start + rows.length; i++) {
                if (!view[i - rows.start])
                    view[i - rows.start] = [];
                if (!cache.getIndex(i))
                    cache.setIndex(i, new bigArray(columnLength));
    
                for (var j = columns.start; j < columns.start + columns.length; j++) {
                    if (!view[i - rows.start][j - columns.start]) {
                        updated = true;
                        cache.getIndex(i).setIndex(j, 
                            view[i - rows.start][j - columns.start] = generate(i, j));
                    }
                }
            }
            
            callback(null, view, updated);
        }
        
        if (this.latency)
            setTimeout(cb, this.latency);
        else
            cb();
        
        return view; //Return cached results
    }
};

function bigArray(size){
    var stores  = [];
    var billion = 1000000000;
    var length  = Math.ceil(size / billion);
    for (var i = 0; i < length - 1; i++)
        stores.push(Array(billion));
    stores.push(Array(size % billion || billion));
    
    // Assuming range never exceeds more than 1 store boundary
    this.slice = function(start, end){
        var startStore = Math.floor(start / billion);
        var startIndex = start % billion;
        
        var endStore = Math.floor(end / billion);
        var endIndex = end % billion;
        
        var subset = [];
        if (startStore == endStore)
            subset = subset.concat(stores[startStore].slice(startIndex, endIndex));
        else {
            subset = subset.concat(stores[startStore].slice(startIndex));
            if (endIndex)
                subset = subset.concat(stores[endStore].slice(0, endIndex));
        }
        
        return subset;
    }
    this.getIndex = function(i){
        var store = Math.floor(i / billion);
        var index = i % billion;
        return stores[store][index];
    }
    this.setIndex = function(i, value){
        var store = Math.floor(i / billion);
        var index = i % billion;
        stores[store][index] = value;
    }
}

module.exports = DataProvider;

});